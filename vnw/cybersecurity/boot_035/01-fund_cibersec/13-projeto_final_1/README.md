# Formação Cybersec - Módulo 1 - Projeto Final 1   <img src="../../0-aux/logo_boot.png" alt="boot_035" width="auto" height="45">

### Repository: [boot](../../../../../)   
### Platform: <a href="../../../../">vnw   <img src="https://github.com/PedroHeeger/my_tech_journey/blob/main/platforms/img/vnw.jpeg" alt="vnw" width="auto" height="25"></a>
### Software/Subject: <a href="../../../">cybersecurity   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/content/cybersecurity.jpg" alt="cybersecurity" width="auto" height="25"></a>
### Bootcamp: <a href="../../">boot_035 (Formação Cybersec)   <img src="../../0-aux/logo_boot.png" alt="boot_035" width="auto" height="25"></a>
### Module: 1. Fundamentos de Cibersegurança

---

Esta pasta refere-se ao projeto final opção 1 do módulo 1 **Fundamentos de Cibersegurança** do bootcamp [**Formação Cybersec**](../../). O artefato entregável principal foi o relatório da análise técnica construído no arquivo [relatorio.md](./relatorio.md). Os demais artefáteis entregáveis fizeram parte do projeto e também estão disponíveis nessa pasta e anexados ao relatório.

### Theme:
- Cybersecurity

### Used Tools:
- Operating System (OS): 
  - Linux   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/linux/linux-original.svg" alt="linux" width="auto" height="25">
  - Windows 11   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/windows11.png" alt="windows11" width="auto" height="25">
- Linux Distribution:
  - Ubuntu   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/ubuntu/ubuntu-plain.svg" alt="ubuntu" width="auto" height="25">
- Cloud:
  - AWS   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon@latest/icons/amazonwebservices/amazonwebservices-original-wordmark.svg" alt="aws" width="auto" height="25">
- Cloud Services:
  - Amazon Elastic Compute Cloud (EC2)   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/cloud/aws_ec2.svg" alt="aws_ec2" width="auto" height="25">
  - Google Drive   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/google_drive.png" alt="google_drive" width="auto" height="25">
- Containerization: 
  - Docker   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/docker/docker-original.svg" alt="docker" width="auto" height="25">
  - Docker Compose   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/docker_compose.png" alt="docker_compose" width="auto" height="25">
- Language:
  - HTML   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/html5/html5-original.svg" alt="html" width="auto" height="25">
  - Markdown   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/markdown/markdown-original.svg" alt="markdown" width="auto" height="25">
- Integrated Development Environment (IDE) and Text Editor:
  - Visual Studio Code (VS Code)   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/vscode/vscode-original.svg" alt="vscode" width="auto" height="25">
- Versioning: 
  - Git   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/git/git-original.svg" alt="git" width="auto" height="25">
- Repository:
  - GitHub   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/github/github-original.svg" alt="github" width="auto" height="25">
- Command Line Interpreter (CLI):
  - AWS Command Line Interface (CLI)   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/cloud/aws_cli.svg" alt="aws_cli" width="auto" height="25">
  - Bash e Sh   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/bash/bash-original.svg" alt="bash_sh" width="auto" height="25">
- Tools:
  - Curl   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/curl.png" alt="curl" width="auto" height="25">
- Network:
  - Arp-scan   <img src="" alt="arp-scan" width="auto" height="25">
  - Domain Information Groper (Dig)   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/dig.jpeg" alt="dig" width="auto" height="25">
  - Iproute   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/iproute.png" alt="iproute" width="auto" height="25">
  - Iputils-ping; Iputils   <img src="" alt="iputils" width="auto" height="25">
  - Netdiscover   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/netdiscover.png" alt="netdiscover" width="auto" height="25">
  - Net-tools   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/net-tools.svg" alt="net-tools" width="auto" height="25">
  - Nmap   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/nmap.png" alt="nmap" width="auto" height="25">
  - Ping   <img src="" alt="iputils" width="auto" height="25">
  - Rustscan   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/rustscan.png" alt="rustscan" width="auto" height="25">
- Offensive Security:
  - Kali Linux   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/kali_linux.png" alt="kali_linux" width="auto" height="25">

---

### Bootcamp Module 1 Final Project 1 Structure
1. <a name="item1">Opção 1 – Projeto Técnico: Mapeamento de Rede em Docker<br>
    1.1. <a href="#item1.1">Reconhecimento Técnico da Infraestrutura</a><br>
    1.2. <a href="#item1.2">Análise de Serviços e Exposição de Ativos</a><br>
    1.3. <a href="#item1.3">Avaliação de Riscos e Exposição</a><br>
    1.4. <a href="#item1.4">Inventário Técnico e Classificação dos Ativos de Rede</a><br>
    1.5. <a href="#item1.5">Diagnóstico e Recomendações</a><br>
    1.6. <a href="#item1.6">Documentação Técnica</a><br>

---

### Objective:
O objetivo deste projeto foi aplicar, de forma prática, os conhecimentos adquiridos sobre reconhecimento, varredura de rede e análise de exposição, por meio da investigação de uma rede corporativa simulada em ambiente **Docker**. A proposta consistiu em assumir o papel de um analista de segurança em uma empresa fictícia e conduzir um mapeamento completo dos ativos e sub-redes, elaborando um diagnóstico técnico preciso das exposições encontradas, bem como suas respectivas soluções. Ao final, toda a análise foi consolidada em um relatório técnico estruturado, contendo o inventário dos ativos, o diagrama da rede, os diagnósticos e recomendações das exposições identificadas, além de um plano de ação baseado na estratégia 80/20.

### Structure:
- Este documento de README, escrito em **Markdown**, descreve todo o desenvolvimento do projeto. Embora não seja um artefato entregável, complementa o projeto.
- [relatorio.md](./relatorio.md): Relatório de análise técnica da rede interna da empresa fictícia. É o principal artefato entregável.
- [softwares.md](./softwares.md): Documento em **Markdown** contendo informações relevantes sobre todos os softwares e ferramentas utilizados na análise técnica. É um anexo do relatório técnico.
- [cmds.md](./cmds.md): Documento em **Markdown** com os comandos executados durante a análise técnica. É um anexo do relatório técnico.
- [diagrama.png](./diagrama.png): Arquivo em **PNG** com o diagrama da topologia de rede, construído no **Draw.io**. É um anexo do relatório técnico.
- [outputs](./outputs): Pasta contendo arquivos em **TXT** com os outputs dos comandos executados. É um anexo do relatório técnico.
- [img](./img): Pasta com imagens (prints) dos outputs dos comandos executados. É um anexo do relatório técnico e utilizado neste arquivo de README.

### Development:
Nesta proposta de projeto, foi elaborado um relatório técnico com base na análise realizada de uma rede interna corporativa simulada em ambiente **Docker**. Para sua construção, foi utilizado um modelo em **Markdown** fornecido pela plataforma do curso. Esse modelo contemplava os seguintes itens: sumário executivo, objetivo, escopo, metodologia, diagrama de rede, diagnóstico (achados), recomendações, plano de ação 80/20, conclusão e anexos. Todo o material do projeto, incluindo o modelo de relatório técnico, os documentos de instrução e os arquivos para construção do ambiente, está disponível neste [link](https://github.com/Kensei-CyberSec-Lab/formacao-cybersec/tree/main/modulo1-fundamentos/projeto_final_opcao_1) do GitHub, repositório oficial deste curso da Vai na Web.

A construção do ambiente foi realizada, assim como nos laboratórios do Módulo 1, utilizando o **Docker** em conjunto com o **WSL**. No entanto, optei por utilizar a plataforma **Play With Docker (PWD)** e, nos momentos em que a memória disponível se mostrou insuficiente, recorri a uma instância do **Amazon Elastic Compute Cloud (EC2)**, na nuvem da **Amazon Web Services (AWS)**, como foi o caso deste projeto.

A criação da instância EC2 foi automatizada por meio do script [ec2Instance.ps1](../../environment/ec2Instance.ps1), desenvolvido em **PowerShell** com comandos da **AWS Command Line Interface (CLI)**, localizado na pasta [environment](../../environment/) deste bootcamp. A instância utilizava a imagem `ami-020cba7c55df1f615`, baseada no sistema operacional **Linux Ubuntu**, com um volume **Amazon Elastic Block Store (EBS)** de `8 GB` do tipo `gp` (General Purpose). O tipo instância definido foi `t3.medium` que tem 2vCPU e 4 gigas de memória. O par de chaves utilizado foi o `keyPairUniversal` já existente na minha conta da **AWS**, e o security group associado foi o `default` da zona de disponibilidade `us-east-1a` (Norte da Virgínia). Além disso, foi utilizado um arquivo de user data para automatizar a instalação do **Git** e do **Docker** durante o provisionamento da instância.

A interação com a instância podia ser realizada tanto pelo console da própria **AWS** quanto por meio de conexão SSH utilizando o software **OpenSSH** executado no **Windows PowerShell** da máquina física. Neste último caso, era necessário fornecer o caminho do arquivo de chave privada, o nome do usuário do sistema operacional e o endereço IP ou DNS público da instância, como no exemplo: `ssh -i "G:/Meu Drive/4_PROJ/scripts/aws/.default/secrets/awsKeyPair/universal\keyPairUniversal.pem" ubuntu@54.160.249.118`. Além disso, o **Security Group** associado à instância precisava conter uma regra de entrada liberando a porta `22` para o IP público da máquina física, a fim de permitir o estabelecimento da conexão SSH.

Com relação a construção do ambiente de laboratório deste projeto, o instrutor do curso disponibilizou um arquivo `docker-compose.yml` que, ao ser executado, criava múltiplos containers e redes virtuais, simulando um ambiente de rede corporativa interna, com servidores, estações de trabalho e sub-redes. Este ambiente foi projetado especificamente para o treinamento de habilidades de reconhecimento e análise de exposição em um cenário controlado. O material de referência para criação do ambiente e instruções do projeto pôde ser consultado no repositório oficial da formação, disponível [neste link](https://github.com/Kensei-CyberSec-Lab/formacao-cybersec/tree/main/modulo1-fundamentos/projeto_final_opcao_1).

#TODO: ESTOU CONCLUÍDO ESSE MATERIAL - PREVISÃO DE FINALIZAÇÃO: 05/08/25










Para executar o ambiente simulado foi utilizado essa instância construída do **Amazon EC2**. Nessa máquina, o repositório da formação completa foi clonado com o comando `git clone https://github.com/Kensei-CyberSec-Lab/formacao-cybersec.git`. Em seguida, foi necessário navegar até a pasta do projeto com o comando `cd formacao-cybersec/modulo1-fundamentos/projeto_final_opcao_1` e executar o comando `docker compose up -d` para iniciar os containers e as redes definidas no arquivo `docker-compose.yml`. Com o comando `docker ps -a`, todos os containers criados (ativos ou inativos) foram listados. Já com o comando `docker network ls`, foi possível visualizar todas as redes construídas. A imagem 01 comprova que o ambiente foi construído com sucesso.

<div align="center"><figure>
    <img src="./img/img01.png" alt="img01"><br>
    <figcaption>Imagem 01.</figcaption>
</figure></div><br>

O container de nome `analyst` foi criado a partir de um `Dockerfile` referenciado no `docker-compose.yml`. Ele utilizava como base uma imagem do **Kali Linux**, e diversas ferramentas úteis foram instaladas automaticamente, como: **Nmap**, **Rustscan**, **Net-Tools**, **Dig**, **Iproute2**, entre outras. Esse container foi utilizado como estação de análise para toda a investigação da rede interna. O acesso ao container se deu por meio do comando `docker exec -it analyst bash`, que abriu um shell **Bash** para interação via CLI.

A rede interna simulada da empresa estava segmentada em três sub-redes, conforme listadas abaixo. Essas subnets são redes do **Docker** que foram construídas automaticamente pelo **Docker Compose** e são visualizadas na imagem 01 acima:
- **Rede `corp_net`**: rede corporativa principal da empresa, formada por estações de trabalho e um servidor web. CIDR: `10.10.10.0/24`.
- **Rede `guest_net`**: rede destinada a visitantes e dispositivos pessoais. CIDR: `10.10.30.0/24`.
- **Rede `infra_net`**: rede de infraestrutura crítica, composta por servidores internos. CIDR: `10.10.50.0/24`.

<a name="item1.1"><h4>1.1. Reconhecimento Técnico da Infraestrutura</h4></a>[Back to summary](#item1)

Com o ambiente construído e, de dentro do container `analyst`, os primeiros comandos foram executados para realizar o reconhecimento inicial. A maioria deles pertence a softwares já instalados nesse container, cuja imagem base era um **Kali Linux** — portanto, o sistema operacional também era um Kali. Os comandos `ip a`, `ip addr` ou `ip address`, pertencentes ao pacote **Iproute2**, e o comando `ifconfig`, do pacote **Net-tools**, foram os primeiros utilizados, exibindo todas as interfaces de rede às quais o container estava conectado. Interfaces como `eth0`, `eth1`, etc., são interfaces de rede **Ethernet** — um padrão tecnológico para redes locais (LAN), originalmente voltado a conexões cabeadas (como cabos de par trançado com conector RJ-45), mas que hoje pode se referir tanto a interfaces físicas quanto virtuais que utilizem esse padrão. Já a interface `lo` representa o **loopback**, usada para que o sistema se comunique consigo mesmo. Ela corresponde ao endereço IP `127.0.0.1`, conhecido como `localhost`. As imagens 02 e 03 mostram os outputs desses comandos, que apresentaram os mesmos resultados.

<div align="center"><figure>
    <img src="./img/img02.png" alt="img02"><br>
    <figcaption>Imagem 02.</figcaption>
</figure></div><br>

<div align="center"><figure>
    <img src="./img/img03.png" alt="img03"><br>
    <figcaption>Imagem 03.</figcaption>
</figure></div><br>

Observou-se que havia uma interface `lo`, correspondente ao loopback, e três interfaces `eth`, cada uma conectada a uma rede distinta. O CIDR (Classless Inter-Domain Routing) de cada interface indicava redes com a mesma máscara (`/24`) e os dois primeiros octetos iguais, sugerindo que todas pertenciam a uma rede maior. Assim, identificou-se que o CIDR da rede interna da empresa era `10.10.0.0/16`, composta por três sub-redes: `10.10.10.0/24` (corp_net), `10.10.30.0/24` (guest_net) e `10.10.50.0/24` (infra_net). Essas sub-redes foram criadas pelo **Docker** para simular o ambiente corporativo. As interfaces do container conectadas a essas redes receberam os IPs `10.10.10.2`, `10.10.30.2` e `10.10.50.5`, respectivamente.

Com a identificação das sub-redes, o próximo passo foi descobrir quais hosts estavam conectados a cada uma delas. Um host é qualquer dispositivo conectado a uma rede que possui um endereço IP e pode enviar ou receber dados. Pode ser um computador (desktop, laptop, servidor), um dispositivo móvel (smartphone, tablet), um equipamento de rede (como impressoras, câmeras IP, roteadores, switches gerenciáveis) ou um container (como no Docker). Neste caso, o próprio container **Kali Linux** utilizado atuava como host em cada uma das sub-redes.

Os softwares **arp-scan** e **netdiscover**, que não estavam instalados no container, foram instalados para realizar o reconhecimento. Em seguida, foram executados seis comandos, dois para cada interface: `arp-scan --interface=eth0 --localnet` e `netdiscover -i eth0 -r 10.10.10.0/24` para a interface `eth0`; `arp-scan --interface=eth1 --localnet` e `netdiscover -i eth1 -r 10.10.30.0/24` para a interface `eth1`; e `arp-scan --interface=eth2 --localnet` e `netdiscover -i eth2 -r 10.10.50.0/24` para a interface `eth2`. Cada par de comandos retornou os mesmos resultados para a interface analisada. As imagens 4 a 9 exibem os outputs desses comandos.

<!-- <div align="center"><figure>
    <img src="./img/img04.png" alt="img04"><br>
    <figcaption>Imagem 04.</figcaption>
</figure></div><br>

<div align="center"><figure>
    <img src="./img/img05.png" alt="img05"><br>
    <figcaption>Imagem 05.</figcaption>
</figure></div><br>

<div align="center"><figure>
    <img src="./img/img06.png" alt="img06"><br>
    <figcaption>Imagem 06.</figcaption>
</figure></div><br>

<div align="center"><figure>
    <img src="./img/img07.png" alt="img07"><br>
    <figcaption>Imagem 07.</figcaption>
</figure></div><br>

<div align="center"><figure>
    <img src="./img/img08.png" alt="img08"><br>
    <figcaption>Imagem 08.</figcaption>
</figure></div><br>

<div align="center"><figure>
    <img src="./img/img09.png" alt="img09"><br>
    <figcaption>Imagem 09.</figcaption>
</figure></div><br> -->

<table style="margin: auto;">
  <tr>
    <td style="text-align: center;">
      <img src="./img/img04.png" alt="img04"><br>
      <figcaption>Imagem 04.</figcaption>
    </td>
    <td style="text-align: center;">
      <img src="./img/img05.png" alt="img05"><br>
      <figcaption>Imagem 05.</figcaption>
    </td>
  </tr>
  <tr>
    <td style="text-align: center;">
      <img src="./img/img06.png" alt="img06"><br>
      <figcaption>Imagem 06.</figcaption>
    </td>
    <td style="text-align: center;">
      <img src="./img/img07.png" alt="img07"><br>
      <figcaption>Imagem 07.</figcaption>
    </td>
  </tr>
  <tr>
    <td style="text-align: center;">
      <img src="./img/img08.png" alt="img08"><br>
      <figcaption>Imagem 08.</figcaption>
    </td>
    <td style="text-align: center;">
      <img src="./img/img09.png" alt="img09"><br>
      <figcaption>Imagem 09.</figcaption>
    </td>
  </tr>
</table>


<div style="display: flex; justify-content: center; gap: 40px; margin-bottom: 20px;">
    <figure style="text-align: center;">
        <img src="./img/img04.png" alt="img04">
        <figcaption>Imagem 04.</figcaption>
    </figure>
    <figure style="text-align: center;">
        <img src="./img/img05.png" alt="img05">
        <figcaption>Imagem 05.</figcaption>
    </figure>
</div>

<div style="display: flex; justify-content: center; gap: 40px; margin-bottom: 20px;">
    <figure style="text-align: center;">
        <img src="./img/img06.png" alt="img06">
        <figcaption>Imagem 06.</figcaption>
    </figure>
    <figure style="text-align: center;">
        <img src="./img/img07.png" alt="img07">
        <figcaption>Imagem 07.</figcaption>
    </figure>
</div>

<div style="display: flex; justify-content: center; gap: 40px; margin-bottom: 20px;">
    <figure style="text-align: center;">
        <img src="./img/img08.png" alt="img08">
        <figcaption>Imagem 08.</figcaption>
    </figure>
    <figure style="text-align: center;">
        <img src="./img/img09.png" alt="img09">
        <figcaption>Imagem 09.</figcaption>
    </figure>
</div>

Analisando os outputs, identificou-se que na sub-rede `10.10.10.0` (`corp_net`) foram encontrados cinco hosts ativos. Na sub-rede `10.10.30.0` (`guest_net`), sete hosts foram identificados, enquanto na sub-rede `10.10.50.0` (`infra_net`) foram descobertos cinco hosts. Em todas as três sub-redes, o container `analyst` não foi considerado na contagem, pois era a máquina a partir da qual os comandos foram executados.

<a name="item1.2"><h4>1.2. Análise de Serviços e Exposição de Ativos</h4></a>[Back to summary](#item1)

A segunda etapa consitiu na varredura detalhada, onde foram utilizados os softwares **Nmap** e **Rustscan** para identificar os serviços de cada host, as portas abertas e os banners. Um banner é uma mensagem de texto ou informação que um serviço de rede (que está escutando numa porta aberta) envia quando alguém conecta ou faz uma requisição. Geralmente ele contém detalhes sobre o serviço, como: Nome do serviço (exemplo: Apache, OpenSSH, Microsoft IIS), Versão do software (exemplo: OpenSSH 7.6p1), Informações adicionais que podem indicar o sistema operacional ou configuração. 

Dessa forma, os softwares que já estavam instalados no container, foram utilizados para identificar cada host de cada sub-rede, do que se tratava, quais portas estavam abertas, identificando assim, os serviços que aquele host executava. Basicamente o que era feito era escaneamentos nos IPs de cada host para procurar essas informações.








<!-- LDAP (Lightweight Directory Access Protocol)
O que é?
LDAP é um protocolo usado para acessar e gerenciar serviços de diretórios na rede. Esses diretórios funcionam como bases de dados especializadas que armazenam informações organizadas, como usuários, grupos, permissões, dispositivos e outras entidades em uma rede.

Para que serve?
Serve principalmente para autenticação, autorização e gerenciamento de informações de usuários e recursos em ambientes corporativos, facilitando o controle centralizado de acesso.
Portas padrão:

389/tcp: Porta padrão para comunicação LDAP sem criptografia (LDAP simples).

636/tcp: Porta padrão para LDAP sobre SSL/TLS (LDAPS), que oferece uma conexão segura.

Por que é importante?
Serviços LDAP são usados em muitas organizações para gerenciar usuários e permissões (como Active Directory, OpenLDAP). Se não estiverem bem configurados, podem expor informações sensíveis ou permitir acessos não autorizados.
 -->




<a name="item1.3"><h4>1.3. Avaliação de Riscos e Exposição</h4></a>[Back to summary](#item1)







<a name="item1.4"><h4>1.4. Inventário Técnico e Classificação dos Ativos de Rede</h4></a>[Back to summary](#item1)









<a name="item1.5"><h4>1.5. Diagnóstico e Recomendações</h4></a>[Back to summary](#item1)







<a name="item1.6"><h4>1.6. Documentação Técnica</h4></a>[Back to summary](#item1)










