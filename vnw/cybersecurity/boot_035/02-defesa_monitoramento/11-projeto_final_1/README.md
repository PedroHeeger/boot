# Forma√ß√£o Cybersec - M√≥dulo 2 - Projeto Final 1   <img src="../../0-aux/logo_boot.png" alt="boot_035" width="auto" height="45">

### Repository: [boot](../../../../../)   
### Platform: <a href="../../../../">vnw   <img src="https://github.com/PedroHeeger/my_tech_journey/blob/main/platforms/img/vnw.jpeg" alt="vnw" width="auto" height="25"></a>
### Software/Subject: <a href="../../../">cybersecurity   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/content/cybersecurity.jpg" alt="cybersecurity" width="auto" height="25"></a>
### Bootcamp: <a href="../../">boot_035 (Forma√ß√£o Cybersec)   <img src="../../0-aux/logo_boot.png" alt="boot_035" width="auto" height="25"></a>
### Module: 2. Defesa & Monitoramento (Blue Team)

---

Esta pasta refere-se ao projeto final op√ß√£o 1 do m√≥dulo 2 **Defesa & Monitoramento (Blue Team)** do bootcamp [**Forma√ß√£o Cybersec**](../../). O artefato entreg√°vel principal foi o relat√≥rio da an√°lise t√©cnica constru√≠do no arquivo [relatorio.md](./relatorio.md). Os demais artef√°teis entreg√°veis fizeram parte do projeto e tamb√©m est√£o dispon√≠veis nessa pasta e anexados ao relat√≥rio.

### Theme:
- Cybersecurity

### Used Tools:
- Operating System (OS): 
  - Linux   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/linux/linux-original.svg" alt="linux" width="auto" height="25">
  - Windows 11   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/windows11.png" alt="windows11" width="auto" height="25">
- Linux Distribution:
  - Ubuntu   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/ubuntu/ubuntu-plain.svg" alt="ubuntu" width="auto" height="25">
- Cloud:
  - AWS   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon@latest/icons/amazonwebservices/amazonwebservices-original-wordmark.svg" alt="aws" width="auto" height="25">
- Cloud Services:
  - Amazon Elastic Compute Cloud (EC2)   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/cloud/aws_ec2.svg" alt="aws_ec2" width="auto" height="25">
  - Google Drive   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/google_drive.png" alt="google_drive" width="auto" height="25">
- Containerization: 
  - Docker   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/docker/docker-original.svg" alt="docker" width="auto" height="25">
  - Docker Compose   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/docker_compose.png" alt="docker_compose" width="auto" height="25">
- Language:
  - HTML   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/html5/html5-original.svg" alt="html" width="auto" height="25">
  - Markdown   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/markdown/markdown-original.svg" alt="markdown" width="auto" height="25">
- Integrated Development Environment (IDE) and Text Editor:
  - Visual Studio Code (VS Code)   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/vscode/vscode-original.svg" alt="vscode" width="auto" height="25">
- Versioning: 
  - Git   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/git/git-original.svg" alt="git" width="auto" height="25">
- Repository:
  - GitHub   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/github/github-original.svg" alt="github" width="auto" height="25">
- Command Line Interpreter (CLI):
  - AWS Command Line Interface (CLI)   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/cloud/aws_cli.svg" alt="aws_cli" width="auto" height="25">
  - Bash e Sh   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/bash/bash-original.svg" alt="bash_sh" width="auto" height="25">
- Tools:
  - Curl   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/curl.png" alt="curl" width="auto" height="25">
- Network:
  - Arp-scan   <img src="" alt="arp-scan" width="auto" height="25">
  - Domain Information Groper (Dig)   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/dig.jpeg" alt="dig" width="auto" height="25">
  - Iproute   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/iproute.png" alt="iproute" width="auto" height="25">
  - Iputils-ping; Iputils   <img src="" alt="iputils" width="auto" height="25">
  - Netdiscover   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/netdiscover.png" alt="netdiscover" width="auto" height="25">
  - Net-tools   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/net-tools.svg" alt="net-tools" width="auto" height="25">
  - Nmap   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/nmap.png" alt="nmap" width="auto" height="25">
  - Ping   <img src="" alt="iputils" width="auto" height="25">
  - Rustscan   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/rustscan.png" alt="rustscan" width="auto" height="25">
- Offensive Security:
  - Kali Linux   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/kali_linux.png" alt="kali_linux" width="auto" height="25">

---

### Bootcamp Module 1 Final Project 1 Structure
1. <a name="item1">Op√ß√£o 1 ‚Äì Projeto T√©cnico: Lab de Seguran√ßa WAF + DVWA<br>
    1.0 <a href="#item1.0">Introdu√ß√£o</a><br>
    1.1 <a href="#item1.1">Configura√ß√£o do DVWA</a><br>
    1.2 <a href="#item1.2">Reconhecimento (Nmap)</a><br>
    1.3 <a href="#item1.3">Teste no Modo Detec√ß√£o</a><br>
    1.4 <a href="#item1.4">Teste no Modo Blocking</a><br>
    1.5 <a href="#item1.5">Monitoramento com Dozzle</a><br>
    1.6 <a href="#item1.6">Coleta de Evid√™ncias</a><br>
    1.7 <a href="#item1.7">Documenta√ß√£o T√©cnica</a><br>

---

### Objective
O objetivo deste projeto foi elaborar um relat√≥rio t√©cnico completo para documentar a execu√ß√£o de um laborat√≥rio controlado em ambiente **Docker**. Esse relat√≥rio deveria conter: capa, sum√°rio executivo (1 p√°gina), objetivo, escopo, metodologia, diagrama/arquitetura, evid√™ncias/diagn√≥stico, recomenda√ß√µes, plano de a√ß√£o, conclus√£o e anexos. Os anexos inclu√≠ram prints das a√ß√µes executadas, arquivos de texto com outputs de comandos ou outros materiais que comprovassem a execu√ß√£o bem-sucedida do laborat√≥rio.  

No laborat√≥rio, o objetivo foi construir um ambiente defensivo utilizando a aplica√ß√£o vulner√°vel **DVWA** protegida por um Web Application Firewall (WAF) **OWASP**. Foram testados os modos de detec√ß√£o e de bloqueio frente a ataques de SQL Injection (SQLi), Cross-Site Scripting (XSS), Command Injection e File Inclusion. Para o monitoramento, foi empregado o **Dozzle**, permitindo a visualiza√ß√£o e an√°lise dos logs do WAF em tempo real.  

### Folder Structure:
- Este documento de README, escrito em **Markdown**, descreve todo o desenvolvimento do projeto. Embora n√£o seja um artefato entreg√°vel, complementa o projeto.
- [relatorio.md](./relatorio.md): Relat√≥rio de an√°lise t√©cnica da rede interna da empresa fict√≠cia. √â o principal artefato entreg√°vel.
- [softwares.md](./softwares.md): Documento em **Markdown** contendo informa√ß√µes relevantes sobre todos os softwares e ferramentas utilizados na an√°lise t√©cnica. √â um anexo do relat√≥rio t√©cnico.
- [cmds.md](./cmds.md): Documento em **Markdown** com os comandos executados durante a an√°lise t√©cnica. √â um anexo do relat√≥rio t√©cnico.
- [diagrama.png](./diagrama.png): Arquivo em **PNG** com o diagrama da topologia de rede, constru√≠do no **Draw.io**. √â um anexo do relat√≥rio t√©cnico.
- [outputs](./outputs): Pasta contendo arquivos em **TXT** com os outputs dos comandos executados. √â um anexo do relat√≥rio t√©cnico.
- [img](./img): Pasta com imagens (prints) dos outputs dos comandos executados. √â um anexo do relat√≥rio t√©cnico e utilizado neste arquivo de README.

### Development:
Em ciberseguran√ßa, √© pr√°tica comum e recomendada realizar laborat√≥rios em ambientes controlados e seguros. Por isso, ferramentas como **Docker** ou m√°quinas virtuais s√£o utilizadas para simular ambientes reais, protegendo a infraestrutura local, uma vez que o uso de ferramentas de ataque ou altera√ß√µes em configura√ß√µes de rede podem comprometer a integridade do sistema. O ambiente de laborat√≥rio √© estruturado em duas partes: a primeira envolve a instala√ß√£o dos softwares que virtualiza√ß√£o um ambiente, como **WSL2**, **Docker** ou **VM VirtualBox**, al√©m de ferramentas de suporte essenciais, como editores de c√≥digo (**Visual Studio Code (VS Code)**) e sistemas de versionamento (**Git**).  

Neste curso, a virtualiza√ß√£o do ambiente foi realizada principalmente com **Docker** em conjunto com **WSL**. No entanto, para a maioria dos labs utilizei o **Docker** em inst√¢ncias do **Amazon Elastic Compute Cloud (EC2)**, na nuvem da **Amazon Web Services (AWS)**, como alternativa de execu√ß√£o. Em pequenos casos, para realizar testes, a plataforma **Play With Docker (PWD)** tamb√©m foi utilizada.

A cria√ß√£o da inst√¢ncia EC2 foi automatizada por meio do script [`ec2Instance.ps1`](../environment/ec2Instance.ps1), desenvolvido em **Windows PowerShell** utilizando comandos da **AWS Command Line Interface (CLI)**. O script est√° localizado na pasta [`environment`](../environment/) deste curso, pois foi o mesmo para todos os m√≥dulos. A inst√¢ncia foi provisionada com a imagem `ami-020cba7c55df1f615`, baseada no sistema operacional **Linux Ubuntu**, associada a um volume do **Amazon Elastic Block Store (EBS)** de `8 GB`, do tipo `gp` (General Purpose). O tipo de inst√¢ncia utilizado foi o `t3.medium`, com 2 vCPUs e 4 GB de mem√≥ria. Para acesso, foi utilizado o par de chaves `keyPairUniversal`, previamente existente na conta da **AWS**, e o grupo de seguran√ßa atribu√≠do √† inst√¢ncia foi o `default` da zona de disponibilidade `us-east-1a` (Norte da Virg√≠nia). Um script de *user data* foi utilizado para automatizar a instala√ß√£o do **Git** e do **Docker** durante o processo de inicializa√ß√£o.

O acesso √† inst√¢ncia podia ser feito tanto pelo console da **AWS** quanto por meio de conex√£o SSH utilizando o **OpenSSH** no **Windows PowerShell** da m√°quina local. Neste √∫ltimo caso, era necess√°rio informar o caminho do arquivo de chave privada, o nome do usu√°rio do sistema e o IP ou DNS p√∫blico da inst√¢ncia. Um exemplo de comando seria: `ssh -i "G:/Meu Drive/4_PROJ/scripts/aws/.default/secrets/awsKeyPair/universal/keyPairUniversal.pem" ubuntu@54.160.249.118`. Al√©m disso, o Security Group associado √† inst√¢ncia precisava conter uma regra de entrada liberando a porta `22` para o IP p√∫blico da m√°quina f√≠sica, a fim de permitir o estabelecimento da conex√£o SSH. As m√°quinas virtuais do **Play With Docker (PWD)** tamb√©m foram acessadas via SSH. Nesse caso, o pr√≥prio ambiente fornecia o comando necess√°rio para a conex√£o, que podia ser executado diretamente no **Windows PowerShell**, sem necessidade de autentica√ß√£o com chave privada ou senha.

A segunda parte do ambiente de laborat√≥rio consiste na constru√ß√£o do ambiente simulado propriamente dito. No caso do **Docker**, isso envolve a cria√ß√£o de containers, redes e volumes, realizada por meio de dois tipos principais de arquivos. O primeiro √© o `docker-compose.yml`, que define de forma serial toda a estrutura a ser criada: quais e quantos containers, suas configura√ß√µes, as imagens que ir√£o utilizar e os volumes e redes que ser√£o estabelecidos. O segundo tipo de arquivo, que pode existir mais de um por laborat√≥rio, s√£o os `Dockerfile`, respons√°veis por criar imagens espec√≠ficas para cada container. Essas imagens podem ser enviadas a reposit√≥rios de imagens **Docker**, como o **DockerHub**, ou referenciadas diretamente no arquivo do **Docker Compose**.

Todos esses arquivos eram preparados pelo instrutor do curso e disponibilizados no [reposit√≥rio](https://github.com/Kensei-CyberSec-Lab/formacao-cybersec/) do curso no perfil da plataforma **Vai na Web** no **GitHub**. O reposit√≥rio era organizado pelos tr√™s m√≥dulos do curso, com pastas correspondentes a cada laborat√≥rio. Geralmente, o n√∫mero do laborat√≥rio coincidia com o n√∫mero da aula, embora nem todos os labs seguissem essa sequ√™ncia e nem todas as aulas tivessem laborat√≥rios. Em cada pasta de laborat√≥rio, al√©m dos arquivos `docker-compose.yml` e `Dockerfile`, podiam existir arquivos complementares, como scripts, textos ou documentos **Markdown**, contendo informa√ß√µes relevantes ou conte√∫dos necess√°rios para a execu√ß√£o do lab. Durante a realiza√ß√£o de cada lab, al√©m de executar os exerc√≠cios, foi feita uma explica√ß√£o detalhada sobre a constru√ß√£o dos arquivos de **Docker Compose**,  **Docker** e as depend√™ncias utilizadas, evidenciando como o ambiente foi estruturado.

Para executar os arquivos e iniciar o ambiente de laborat√≥rio, a sequ√™ncia de comandos utilizada era a seguinte:
- `git clone https://github.com/Kensei-CyberSec-Lab/formacao-cybersec.git`: Clonagem do reposit√≥rio do bootcamp para o ambiente local, seja no **WSL**, em m√°quinas virtuais ou, como no meu caso, em inst√¢ncias **Amazon EC2**.
- `cd formacao-cybersec/modulo2-defesa-monitoramento/lab_1`: Navega√ß√£o at√© o diret√≥rio do laborat√≥rio a ser executado. Para outros labs, bastava alterar as duas √∫ltimas pastas do caminho para o m√≥dulo e lab correspondentes.
- `docker compose up -d`: Inicializa√ß√£o do ambiente com **Docker Compose**. Este comando deve ser executado na pasta onde o arquivo `docker-compose.yml` est√° localizado.
- `docker ps` e `docker network ls`: Verifica√ß√£o dos containers ativos e das redes existentes no ambiente.
- `docker exec -it kali /bin/bash`: Acesso a um container em execu√ß√£o. Basta substituir `kali` pelo nome do container que se deseja acessar.
- `docker compose down`: Encerramento do ambiente. Assim como na inicializa√ß√£o, este comando deve ser executado na pasta onde se encontra o arquivo `docker-compose.yml`.
- `docker system prune -f`: Remo√ß√£o containers parados, redes n√£o usadas, imagens dangling (imagens sem tags) e caches de build.
- `docker system prune -a`: Remo√ß√£o containers parados, redes n√£o usadas, imagens dangling (imagens sem tags) e caches de build, al√©m de remo√ß√£o de todas as imagens n√£o usadas por containers.

Os laborat√≥rios de ciberseguran√ßa s√£o organizados com m√°quinas de ataque, geralmente uma **Kali Linux**, e m√°quinas alvo ou de defesa, que s√£o os sistemas onde os ataques s√£o realizados. Pode haver m√∫ltiplas m√°quinas de cada tipo, sendo comum que algumas m√°quinas de defesa sejam propositalmente vulner√°veis, incluindo aplica√ß√µes web criadas para testes. Como o ambiente √© simulado via **Docker**, termos como servidor, m√°quina, container ou host frequentemente se referem aos containers que representam as m√°quinas simuladas. Al√©m disso, √© importante ter em mente que existem outras duas camadas no ambiente: a m√°quina f√≠sica, no caso meu computador pessoal **Windows**, e a m√°quina virtual fornecida pela **AWS** ou pelo **Play With Docker (PWD)**, que hospeda e executa os containers do **Docker**.

Outra parte importante dos laborat√≥rios foram os *Capture The Flag (CTF)*, desafios t√©cnicos amplamente utilizados na √°rea de ciberseguran√ßa para desenvolver e validar conhecimento pr√°tico. Cada desafio apresenta um cen√°rio espec√≠fico ‚Äî como explora√ß√£o de vulnerabilidades, an√°lise de tr√°fego, OSINT ou engenharia reversa ‚Äî e exige que o participante realize uma a√ß√£o ou resolva um problema para obter a flag. A flag n√£o se limita a uma string ou c√≥digo a ser encontrado, ela representa a prova de que o objetivo do desafio foi cumprido com sucesso. Ao longo dos laborat√≥rios do curso, diversos CTFs foram incorporados ao ambiente simulado, servindo como etapas pr√°ticas de valida√ß√£o do conte√∫do e permitindo aplicar, de forma objetiva, os conceitos aprendidos. Dessa forma, os laborat√≥rios n√£o apenas simularam cen√°rios reais de ataque e defesa, como tamb√©m proporcionaram desafios progressivos que refor√ßaram o racioc√≠nio l√≥gico, a an√°lise t√©cnica e a consolida√ß√£o do conhecimento.

<a name="item1.0"><h4>1.0 Introdu√ß√£o</h4></a> [Back to summary](#item1)

O desafio de projeto 1 deste m√≥dulo consistiu na execu√ß√£o de um laborat√≥rio espec√≠fico, seguido da elabora√ß√£o de um relat√≥rio t√©cnico contendo as devidas comprova√ß√µes. Para facilitar a compreens√£o, o ambiente do laborat√≥rio foi detalhado a seguir. Observa-se que quatro containers foram constru√≠dos em uma mesma rede **Docker**, sendo eles: a m√°quina de ataque (`kali_lab35`), a aplica√ß√£o web vulner√°vel **Damn Vulnerable Web Application (DVWA)** (`dvwa`), o Web Application Firewall (WAF) **OWASP ModSecurity Core Rule Set (OWASP ModSecurity CRS)** (`waf_modsec`) e o container do **Dozzle** (`dozzle`).

<details><summary><strong>Ambiente de Laborat√≥rio</strong></summary>
  <ul>
    <li><details><summary><strong>Docker Compose</strong></summary>
      <ul>
        <li><details><summary><strong>kali_lab35</strong></summary>
          <ul>
            <li><strong>build:</strong> Define que a imagem do container ser√° constru√≠da a partir do diret√≥rio atual (`.`) utilizando o arquivo <code>Dockerfile.kali</code> como receita de constru√ß√£o.</li>
            <li><strong>container_name:</strong> Define o nome do container de forma expl√≠cita como <code>kali_lab35</code>.</li>
            <li><code>tty: true</code>: Permite alocar um terminal interativo, facilitando o acesso ao container via <code>docker exec -it</code> e mantendo-o ativo.</li>
            <li><strong>volumes:</strong> <code>./scripts:/scripts</code> ‚Äî Monta scripts locais dentro do container.</li>
            <li><strong>networks:</strong> Conecta o container √† rede <code>labnet35</code> e define o IP est√°tico <code>192.168.35.11</code> dentro dessa rede.</li>
          </ul>
        </details></li>
        <li><details><summary><strong>waf_modsec</strong></summary>
          <ul>
            <li><strong>image:</strong> owasp/modsecurity-crs:nginx-alpine ‚Äî Container WAF com regras do OWASP ModSecurity Core Rule Set.</li>
            <li><strong>container_name:</strong> Define o nome do container de forma expl√≠cita como <code>waf_modsec</code>.</li>
            <li><strong>environment:</strong>
              <ul>
                <li><code>BACKEND=http://dvwa:80</code> ‚Äî Proxy_pass para aplica√ß√£o DVWA, todas as requisi√ß√µes que chegam ao WAF ser√£o enviadas para o container DVWA na porta 80.</li>
                <li><code>SERVER_NAME=localhost</code> ‚Äî Define o hostname do WAF.</li>
                <li><code>MODSEC_RULE_ENGINE=On</code> ‚Äî Habilita bloqueio de ataques.</li>
                <li><code>MODSEC_RULE_ENGINE=DetectionOnly</code> ‚Äî Habilita apenas a detec√ß√£o de ataques.</li>
                <li><code>BLOCKING_PARANOIA=1</code> ‚Äî Define o n√≠vel de paranoia para bloqueio de ataques.</li>
                <li><code>DETECTION_PARANOIA=1</code> ‚Äî Define o n√≠vel de paranoia para detec√ß√£o de ataques.</li>
              </ul>
            </li>
            <li><strong>depends_on:</strong> <code>dvwa</code> ‚Äî Aguarda a aplica√ß√£o DVWA estar dispon√≠vel antes de iniciar o WAF.</li>
            <li><strong>ports:</strong> <code>8080:8080</code> ‚Äî Mapeia a porta 8080 do host para o container, permitindo acesso externo ao WAF.</li>
            <li><strong>networks:</strong> Conecta o container √† rede <code>labnet35</code> com IP est√°tico <code>192.168.35.30</code>.</li>
          </ul>
        </details></li>
        <li><details><summary><strong>dvwa</strong></summary>
          <ul>
            <li><strong>image:</strong> vulnerables/web-dvwa ‚Äî Container da aplica√ß√£o DVWA para testes de seguran√ßa.</li>
            <li><strong>container_name:</strong> Define o nome do container de forma expl√≠cita como <code>dvwa</code>.</li>
            <li><strong>networks:</strong> Conecta o container √† rede <code>labnet35</code> com IP est√°tico <code>192.168.35.40</code>.</li>
          </ul>
        </details></li>
        <li><details><summary><strong>dozzle</strong></summary>
          <ul>
            <li><strong>image:</strong> amir20/dozzle:latest ‚Äî Visualizador de logs em tempo real para containers Docker via interface web.</li>
            <li><strong>container_name:</strong> Define o nome do container de forma expl√≠cita como <code>dozzle</code>.</li>
            <li><strong>ports:</strong> <code>9999:8080</code> ‚Äî Mapeia a porta 8080 do container para 9999 do host.</li>
            <li><strong>environment:</strong>
              <ul>
                <li><code>DOZZLE_USERNAME=admin</code> ‚Äî Usu√°rio de login do Dozzle.</li>
                <li><code>DOZZLE_PASSWORD=admin</code> ‚Äî Senha de login do Dozzle.</li>
              </ul>
            </li>
            <li><strong>volumes:</strong> <code>/var/run/docker.sock:/var/run/docker.sock:ro</code> ‚Äî Permite leitura dos logs de todos os containers do host.</li>
            <li><strong>networks:</strong> Conecta o container √† rede <code>labnet35</code> com IP est√°tico <code>192.168.35.50</code>.</li>
          </ul>
        </details></li>
        <li><details><summary><strong>labnet35</strong></summary>
          <ul>
            <li><code>driver: bridge</code> ‚Äî Rede do tipo bridge, conectando containers isoladamente dentro do host.</li>
            <li><strong>ipam:</strong>
              <ul>
                <li><strong>config:</strong>
                  <ul>
                    <li><code>subnet: 192.168.35.0/24</code> ‚Äî Define o intervalo de IPs dispon√≠veis na rede, permitindo atribui√ß√£o de IPs est√°ticos.</li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </details></li>
      </ul>
    </details></li>
    <li><details><summary><strong>Dockerfile</strong></summary>
      <ul>
        <li><details><summary><strong>Dockerfile.kali</strong></summary>
          <ul>
            <li><code>FROM kalilinux/kali-rolling</code> ‚Äî Imagem base do Kali Linux rolling release.</li>
            <li><code>RUN apt-get update && DEBIAN_FRONTEND=noninteractive apt-get install -y nmap gobuster sqlmap tcpdump iputils-ping curl wget && rm -rf /var/lib/apt/lists/*</code> ‚Äî Instala ferramentas essenciais de pentest e limpa cache.</li>
            <li><code>CMD ["/bin/bash"]</code> ‚Äî Mant√©m o container ativo com shell interativo.</li>
          </ul>
        </details></li>
      </ul>
    </details></li>
  </ul>
</details>

Neste laborat√≥rio, quatro tipos de ataques ‚Äî SQL Injection (SQLi), Cross-Site Scripting (XSS), Command Injection e File Inclusion ‚Äî foram executados na aplica√ß√£o web vulner√°vel **DVWA** para avaliar o comportamento do WAF, que atuava como camada de prote√ß√£o. O WAF foi testado em dois modos: modo de detec√ß√£o, que apenas identificava os ataques sem bloque√°-los, e modo de bloqueio, que al√©m de detectar, tamb√©m impedia a execu√ß√£o do ataque. √â importante destacar que o **OWASP ModSecurity Core Rule Set (OWASP ModSecurity CRS)** n√£o √©, por si s√≥, um WAF, mas sim um conjunto de regras de seguran√ßa pr√©-configuradas para o **ModSecurity**, que √© o verdadeiro firewall de aplica√ß√µes web (WAF). Esse conjunto de regras auxilia na prote√ß√£o de aplica√ß√µes contra ataques comuns, como inje√ß√£o de SQL, XSS e execu√ß√£o remota de c√≥digo.

Paralelamente, o software **Dozzle** foi utilizado para monitoramento, j√° que o container possu√≠a um mapeamento de volume que direcionava todos os logs do **Docker** do host (inst√¢ncia **Amazon EC2**) para o container (`/var/run/docker.sock:/var/run/docker.sock:ro`). O **Dozzle** oferece uma interface web leve para visualiza√ß√£o em tempo real dos logs dos containers **Docker**, permitindo o monitoramento de m√∫ltiplos containers de maneira simples, sem a necessidade de acessar diretamente o terminal.

A imagem 01 abaixo mostra todos os containers em execu√ß√£o na inst√¢ncia do **Amazon EC2**.

<div align="center"><figure>
    <img src="./img/img01.png" alt="img01"><br>
    <figcaption>Imagem 01.</figcaption>
</figure></div><br>


üéØ Configura√ß√£o do DVWA
1. Acessar DVWA no Navegador
2. Fazer Login
3. Configurar Banco de Dados
4. Configurar N√≠vel de Seguran√ßa

üîç Reconhecimento (Nmap)
1. Entrar no Container Kali
2. Executar Scan Nmap
3. Sair do Container

üïµÔ∏è Teste no Modo Detec√ß√£o
1. Configurar WAF para Modo Detec√ß√£o
2. Recriar o Container WAF
3. Testar Ataque SQLi (Deve Passar)
4. Testar Ataque XSS (Deve Passar)

üö´ Teste no Modo Blocking
1. Configurar WAF para Modo Blocking
2. Recriar o Container WAF
3. Testar Ataque SQLi (Deve ser Bloqueado)
4. Testar Ataque XSS (Deve ser Bloqueado)

üìä Monitoramento com Dozzle
1. Acessar Interface Dozzle
2. Fazer Login no Dozzle
3. Visualizar Logs do WAF
4. Analisar Logs Estruturados

üìã Coleta de Evid√™ncias
1. Capturar Logs Detalhados
2. Fazer Screenshots
3. Documentar Timeline NIST IR



- Rede interna x externa, Kali desprezivel?

- WAF <> Iptables <> Seguran√ßa do DVWA
  - Pra que iptables, n√£o j√° tenho WAF defendendo, seria s√≥ uma prote√ß√£o a mais ne?

- XSS Armazenado <> XSS Refletido


<a name="item1.1"><h4>1.1 Configura√ß√£o do DVWA</h4></a> [Back to summary](#item1)

O primeiro passo deste laborat√≥rio foi a configura√ß√£o da aplica√ß√£o web **DVWA**. Em vez de acessar o container diretamente, o mapeamento de portas (port forwarding) foi realizado no container WAF, que direcionava o tr√°fego para a aplica√ß√£o, mantendo-a protegida. Observando o **Docker Compose**, nota-se que havia o port forwarding `"8080:8080"` no WAF, ou seja, a porta do container era mapeada para a porta correspondente no host (inst√¢ncia EC2). Dessa forma, o fluxo de comunica√ß√£o era: container `dvwa` ‚Üí container `waf_modsec` ‚Üí inst√¢ncia EC2. Assim, ao criar uma regra no security group da inst√¢ncia, liberando a porta `8080` para o IP da m√°quina f√≠sica **Windows**, era poss√≠vel acessar a aplica√ß√£o vulner√°vel **DVWA** pelo navegador daa m√°quina f√≠sica, como mostrado na imagem 02.

<div align="center"><figure>
    <img src="./img/img02.png" alt="img02"><br>
    <figcaption>Imagem 02.</figcaption>
</figure></div><br>

Na p√°gina inicial da aplica√ß√£o, era solicitado o login, cujo padr√£o no **DVWA** era usu√°rio `admin` e senha `password`. Ap√≥s a autentica√ß√£o, foi clicado em `Setup` no menu lateral e, em seguida, em `Create / Reset Database` para criar o banco de dados ou recri√°-lo caso j√° existisse. Com a mensagem de sucesso, a p√°gina foi alterada para `DVWA Security`, permitindo confirmar que o n√≠vel de seguran√ßa estava definido como **Low** (Baixo), o qual era necess√°rio para que o WAF pudesse atuar sobre a aplica√ß√£o. A imagem 03 confirma que o n√≠vel de seguran√ßa estava configurado como **Low**.

<div align="center"><figure>
    <img src="./img/img03.png" alt="img03"><br>
    <figcaption>Imagem 03.</figcaption>
</figure></div><br>

<a name="item1.2"><h4>1.2 Reconhecimento (Nmap)</h4></a> [Back to summary](#item1)

O navegador da m√°quina f√≠sica permaneceu aberto na aplica√ß√£o enquanto os pr√≥ximos passos eram realizados. O container de ataque **Kali Linux** foi acessado com o comando `docker exec -it kali_lab35 /bin/bash` a partir da sess√£o remota estabelecida com a inst√¢ncia EC2 usando o **Windows PowerShell**. Em seguida, foi realizada uma varredura TCP SYN para descobrir portas abertas e identificar os servi√ßos e suas vers√µes no container `waf_modsec`, utilizando o comando `nmap -sS -sV waf_modsec`. A varredura revelou duas portas abertas: a porta `8080`, que executava o servi√ßo **HTTP** com **Nginx**, e a porta `8443`, que executava **HTTPS** tamb√©m com **Nginx** (conforme mostrado na imagem 04).

<div align="center"><figure>
    <img src="./img/img04.png" alt="img04"><br>
    <figcaption>Imagem 04.</figcaption>
</figure></div><br>

Ap√≥s reconhecimento, o acesso ao container de ataque foi finalizado.

<a name="item1.3"><h4>1.3 Teste no Modo Detec√ß√£o</h4></a>[Back to summary](#item1)

Na inst√¢ncia **Amazon EC2**, onde os containers estavam em execu√ß√£o, o arquivo `docker-compose.yml` precisou ser modificado. O container do firewall havia sido implantado com a configura√ß√£o `MODSEC_RULE_ENGINE=On`, correspondente ao modo de bloqueio. Como o objetivo nesta etapa era testar o modo de detec√ß√£o, essa configura√ß√£o foi comentada e a configura√ß√£o `MODSEC_RULE_ENGINE=DetectionOnly` foi descomentada. Para aplicar as altera√ß√µes aos containers, foi executado o comando `docker compose up -d --force-recreate waf_modsec`, recriando todos os containers que foram modificados.

A partir deste ponto, iniciou-se a execu√ß√£o dos quatro ataques. Como eles seriam realizados a partir do container **Kali Linux**, foi necess√°rio acess√°-lo novamente com o comando `docker exec -it kali_lab35 /bin/bash`. Dentro do container, o primeiro ataque realizado foi o de inje√ß√£o SQL, executado utilizando o **Curl**. O comando utilizado foi detalhado em suas partes a seguir:
- `curl`: Ferramenta de linha de comando para realizar requisi√ß√µes HTTP.  
- `-s`: Modo silencioso (silent), que suprime o progresso da requisi√ß√£o e mensagens de erro, deixando a sa√≠da limpa.  
- `"http://waf_modsec:8080/vulnerabilities/sqli/?id=1'+OR+'1'='1'--+-&Submit=Submit"`: URL alvo da requisi√ß√£o, contendo:
  - `waf_modsec:8080`: host e porta do container WAF que encaminha para a aplica√ß√£o DVWA.  
  - `/vulnerabilities/sqli/`: endpoint da aplica√ß√£o vulner√°vel √† SQL Injection.  
  - `?id=1'+OR+'1'='1'--+-`: payload de inje√ß√£o SQL que manipula o par√¢metro `id` para sempre retornar verdadeiro. Cada parte do payload funciona da seguinte forma:  
    - `1'` (SQL: `1'`): fecha a aspa que delimita o valor do par√¢metro `id` na query original da aplica√ß√£o.  
    - `+OR+'1'='1'`(SQL: ` OR '1'='1'`): adiciona uma condi√ß√£o l√≥gica que sempre √© verdadeira, for√ßando a query a retornar todos os registros. O caractere `+` representa um espa√ßo na URL.
    - `--+-` (SQL: `-- -`): inicia um coment√°rio que ignora o restante da query original, garantindo que nenhuma outra cl√°usula interfira no ataque.  
  - `&Submit=Submit`: par√¢metro enviado pelo formul√°rio da aplica√ß√£o simulando o clique no bot√£o de envio.  
- `-H "Host: dvwa"`: Cabe√ßalho HTTP definindo o host como `dvwa`, necess√°rio para o roteamento correto dentro do Docker.  
- `-H "Cookie: PHPSESSID=test; security=low"`: Cabe√ßalho HTTP com cookies da sess√£o, onde:
  - `PHPSESSID=test`: identifica a sess√£o da aplica√ß√£o.  
  - `security=low`: define o n√≠vel de seguran√ßa da DVWA como baixo, permitindo que o ataque seja executado.  
- `-w "Status: %{http_code}\n"`: Formata a sa√≠da exibindo o c√≥digo HTTP retornado pela requisi√ß√£o, permitindo verificar se o ataque foi processado com sucesso.

```bash
curl -s "http://waf_modsec:8080/vulnerabilities/sqli/?id=1'+OR+'1'='1'--+-&Submit=Submit" -H "Host: dvwa" -H "Cookie: PHPSESSID=test; security=low" -w "Status: %{http_code}\n"
```

Basicamente, este comando acessava o endpoint `/vulnerabilities/sqli/` da aplica√ß√£o web vulner√°vel **DVWA** atrav√©s do container do WAF, enviando o payload `?id=1'+OR+'1'='1'--+-` no formul√°rio junto com o par√¢metro `&Submit=Submit`, que simulava o envio do formul√°rio na aplica√ß√£o. O cabe√ßalho `-H "Host: dvwa"` indicava que o host alvo era o container **DVWA**, enquanto o cabe√ßalho `-H "Cookie: PHPSESSID=test; security=low"` fornecia a sess√£o da aplica√ß√£o e definia o n√≠vel de seguran√ßa como baixo. O par√¢metro `-w "Status: %{http_code}\n"` apenas formatava a sa√≠da do comando. O payload manipulava o par√¢metro `id` com uma condi√ß√£o espec√≠fica e adicionava uma segunda condi√ß√£o que sempre retornava verdadeira (`'1'='1'`), garantindo que todos os dados fossem exibidos, desprezando os filtros definidos. A imagem 05 evidencia que o ataque realizado foi detectado pelo WAF, mas n√£o foi bloqueado

<div align="center"><figure>
    <img src="./img/img05.png" alt="img05"><br>
    <figcaption>Imagem 05.</figcaption>
</figure></div><br>

Antes de prosseguir para o segundo ataque, o teste de SQL Injection foi realizado diretamente atrav√©s da interface gr√°fica do **DVWA**, acessada pelo navegador da m√°quina f√≠sica **Windows**. Como o container do **OWASP ModSecurity CRS** estava posicionado √† frente da aplica√ß√£o web **DVWA** e possu√≠a mapeamento de portas na porta `8080`, era poss√≠vel acessar o **DVWA** pelo IP ou DNS p√∫blico da inst√¢ncia **Amazon EC2**, que j√° tinha a regra no grupo de seguran√ßa permitindo comunica√ß√£o com o IP da m√°quina f√≠sica. Dentro do **DVWA**, na se√ß√£o `SQL Injection`, o payload `1'+OR+'1'='1'--+-` foi inserido no campo `User ID` e enviado ao clicar no bot√£o `Submit`. A aplica√ß√£o ent√£o retornou os nomes de todos os usu√°rios do banco de dados, conforme ilustrado na imagem 06.

<div align="center"><figure>
    <img src="./img/img06.png" alt="img06"><br>
    <figcaption>Imagem 06.</figcaption>
</figure></div><br>

O segundo ataque realizado foi um Cross-Site Scripting (XSS) refletido, tamb√©m executado via **Curl** para testar a detec√ß√£o do WAF. O comando utilizado foi `curl -s "http://waf_modsec:8080/vulnerabilities/xss_r/?name=%3Cscript%3Ealert%28%22XSS%22%29%3C/script%3E" -H "Host: dvwa" -H "Cookie: security=low" -w "Status: %{http_code}\n"`. A seguir, o detalhamento de cada parte do comando:
- `curl`: Ferramenta de linha de comando para realizar requisi√ß√µes HTTP.  
- `-s`: Modo silencioso (silent), que suprime o progresso da requisi√ß√£o e mensagens de erro, deixando a sa√≠da limpa.  
- `"http://waf_modsec:8080/vulnerabilities/xss_r/?name=%3Cscript%3Ealert%28%22XSS%22%29%3C/script%3E"`: URL alvo da requisi√ß√£o, contendo:
  - `waf_modsec:8080`: host e porta do container WAF que encaminha para a aplica√ß√£o DVWA.  
  - `/vulnerabilities/xss_r/`: endpoint da aplica√ß√£o vulner√°vel a Cross-Site Scripting refletido.  
  - `?name=%3Cscript%3Ealert%28%22XSS%22%29%3C/script%3E`: par√¢metro `name` com o payload URL-encoded. Ao ser decodificado pelo servidor, esse valor corresponde a `<script>alert("XSS")</script>`, ou seja:
    - `%3C` ‚Üí `<` e `%3E` ‚Üí `>`: delimitadores de tag HTML.  
    - `alert%28%22XSS%22%29` ‚Üí `alert("XSS")`: chamada JavaScript.  
    - Se a aplica√ß√£o reflete esse valor no HTML sem escape, o `<script>` √© interpretado pelo navegador e o JavaScript √© executado.
- `-H "Host: dvwa"`: Cabe√ßalho HTTP definindo o host como `dvwa`, necess√°rio para o roteamento correto dentro do ambiente Docker.  
- `-H "Cookie: security=low"`: Cabe√ßalho HTTP com cookie que define o n√≠vel de seguran√ßa da DVWA como baixo, permitindo que o ataque seja executado.  
- `-w "Status: %{http_code}\n"`: Formata a sa√≠da exibindo o c√≥digo HTTP retornado pela requisi√ß√£o, permitindo confirmar se a requisi√ß√£o foi processada com sucesso.  

A execu√ß√£o deste ataque foi semelhante ao anterior, pois ambos utilizavam requisi√ß√µes HTTP para explorar a aplica√ß√£o web vulner√°vel **DVWA**. A diferen√ßa principal foi o endpoint alvo, que neste caso era `/vulnerabilities/xss_r/`, e o payload, que consistia em `?name=%3Cscript%3Ealert%28%22XSS%22%29%3C/script%3E`. N√£o houve necessidade de enviar dados via formul√°rio, j√° que a requisi√ß√£o n√£o era do tipo POST. No cabe√ßalho HTTP, n√£o foi preciso incluir a sess√£o da aplica√ß√£o, sendo definido apenas o n√≠vel de seguran√ßa como `low`, requisito importante, pois n√≠veis mais altos da **DVWA** impediriam a execu√ß√£o do ataque mesmo sem interven√ß√£o do WAF. O payload inserido no campo `name` continha o c√≥digo **JavaScript** `<script>alert("XSS")</script>`, utilizado apenas para testar se a p√°gina refletia o input do usu√°rio sem escape, confirmando a vulnerabilidade e permitindo a execu√ß√£o de comandos. A imagem 07 demonstra que o WAF detectou o ataque, mas n√£o o bloqueou, mantendo o modo de detec√ß√£o ativo.

<div align="center"><figure>
    <img src="./img/img07.png" alt="img07"><br>
    <figcaption>Imagem 07.</figcaption>
</figure></div><br>

Esse mesmo ataque tamb√©m foi realizado atrav√©s da interface gr√°fica, acessando a sess√£o `XSS (Reflected)` da aplica√ß√£o. No √∫nico campo do formul√°rio foi inserido o payload `<script>alert("XSS")</script>` e, ao clicar no bot√£o `Submit`, o c√≥digo foi executado no navegador da m√°quina f√≠sica, exibindo a mensagem de alerta, conforme evidenciado na imagem 08.

<div align="center"><figure>
    <img src="./img/img08.png" alt="img08"><br>
    <figcaption>Imagem 08.</figcaption>
</figure></div><br>

O terceiro ataque foi o de Command Injection que... Ele tamb√©m foi executado com o **Curl** no container de ataque atrav√©s do comando `curl -s "http://waf_modsec:8080/vulnerabilities/command/?ip=127.0.0.1;ls" -H "Host: dvwa" -H "Cookie: security=low" -w "Status: %{http_code}\n"`. A explica√ß√£o detalhada do comando √© listada abaixo:

O terceiro ataque foi o de Command Injection, que tamb√©m foi executado com o **Curl** no container de ataque atrav√©s do comando `curl -s "http://waf_modsec:8080/vulnerabilities/command/?ip=127.0.0.1;ls" -H "Host: dvwa" -H "Cookie: security=low" -w "Status: %{http_code}\n"`. A explica√ß√£o detalhada do comando √© listada abaixo:
- `curl`: Ferramenta de linha de comando para enviar requisi√ß√µes HTTP.  
- `-s`: Modo silencioso (silent), que suprime o progresso da requisi√ß√£o e mensagens de erro, mantendo a sa√≠da limpa.  
- `"http://waf_modsec:8080/vulnerabilities/command/?ip=127.0.0.1;ls"`: URL alvo da requisi√ß√£o, contendo:  
  - `waf_modsec:8080`: host e porta do container WAF que encaminha para a aplica√ß√£o DVWA.  
  - `/vulnerabilities/command/`: endpoint da aplica√ß√£o vulner√°vel a Command Injection.  
  - `?ip=127.0.0.1;ls`: payload de inje√ß√£o de comando que manipula o par√¢metro `ip` para executar comandos arbitr√°rios. Cada parte funciona da seguinte forma:  
    - `127.0.0.1`: valor leg√≠timo do par√¢metro, representando o host a ser pingado.  
    - `;ls`: comando injetado, separado por `;`, que lista arquivos do servidor.  
- `-H "Host: dvwa"`: Cabe√ßalho HTTP definindo o host como `dvwa`, necess√°rio para o roteamento correto dentro do Docker.  
- `-H "Cookie: security=low"`: Cabe√ßalho HTTP definindo o n√≠vel de seguran√ßa da DVWA como baixo, permitindo que o ataque seja executado.  
- `-w "Status: %{http_code}\n"`: Formata a sa√≠da exibindo o c√≥digo HTTP retornado pela requisi√ß√£o, permitindo verificar se o ataque foi processado com sucesso.

Assim como os dois ataques anteriores, este tamb√©m foi realizado por meio de uma requisi√ß√£o HTTP, alterando apenas o endpoint para a se√ß√£o apropriada do site (`/vulnerabilities/command/`) e o payload para `?ip=127.0.0.1;ls`. Esse payload preenchia o campo de IP com o endere√ßo `127.0.0.1`, que correspondia ao localhost do container `dvwa`, e inclu√≠a um comando adicional. O valor do campo era utilizado como alvo em uma execu√ß√£o do comando `ping` no servidor, mas devido ao comando injetado `ls`, ap√≥s o ping o servidor tamb√©m listava os arquivos presentes no diret√≥rio da aplica√ß√£o web vulner√°vel. A imagem 09 mostra o output do comando, evidenciando tanto o ping quanto a listagem de arquivos.

<div align="center"><figure>
    <img src="./img/img09.png" alt="img09"><br>
    <figcaption>Imagem 09.</figcaption>
</figure></div><br>

Na interface gr√°fica, o mesmo ataque foi realizado acessando a se√ß√£o `Command Injection` do **DVWA** pelo navegador da m√°quina f√≠sica. No campo dispon√≠vel, foi inserido o mesmo payload `127.0.0.1;ls`, obtendo o mesmo resultado observado pelo **Curl**. A imagem 10 mostra o output do comando executado diretamente pela interface gr√°fica.

<div align="center"><figure>
    <img src="./img/img10.png" alt="img10"><br>
    <figcaption>Imagem 10.</figcaption>
</figure></div><br>







<div align="center"><figure>
    <img src="./img/img11.png" alt="img11"><br>
    <figcaption>Imagem 11.</figcaption>
</figure></div><br>

<div align="center"><figure>
    <img src="./img/img12.png" alt="img12"><br>
    <figcaption>Imagem 12.</figcaption>
</figure></div><br>

<div align="center"><figure>
    <img src="./img/img13.png" alt="img13"><br>
    <figcaption>Imagem 13.</figcaption>
</figure></div><br>

<div align="center"><figure>
    <img src="./img/img14.png" alt="img14"><br>
    <figcaption>Imagem 14.</figcaption>
</figure></div><br>

<div align="center"><figure>
    <img src="./img/img15.png" alt="img15"><br>
    <figcaption>Imagem 15.</figcaption>
</figure></div><br>

<div align="center"><figure>
    <img src="./img/img16.png" alt="img16"><br>
    <figcaption>Imagem 16.</figcaption>
</figure></div><br>

<div align="center"><figure>
    <img src="./img/img17.png" alt="img17"><br>
    <figcaption>Imagem 17.</figcaption>
</figure></div><br>



<div align="center"><figure>
    <img src="./img/img18.png" alt="img18"><br>
    <figcaption>Imagem 18.</figcaption>
</figure></div><br>



<div align="center"><figure>
    <img src="./img/img19.png" alt="img19"><br>
    <figcaption>Imagem 19.</figcaption>
</figure></div><br>

<div align="center"><figure>
    <img src="./img/img20.png" alt="img20"><br>
    <figcaption>Imagem 20.</figcaption>
</figure></div><br>

<div align="center"><figure>
    <img src="./img/img21.png" alt="img21"><br>
    <figcaption>Imagem 21.</figcaption>
</figure></div><br>

<div align="center"><figure>
    <img src="./img/img22.png" alt="img22"><br>
    <figcaption>Imagem 22.</figcaption>
</figure></div><br>

<div align="center"><figure>
    <img src="./img/img23.png" alt="img23"><br>
    <figcaption>Imagem 23.</figcaption>
</figure></div><br>

<div align="center"><figure>
    <img src="./img/img24.png" alt="img24"><br>
    <figcaption>Imagem 24.</figcaption>
</figure></div><br>

<div align="center"><figure>
    <img src="./img/img25.png" alt="img25"><br>
    <figcaption>Imagem 25.</figcaption>
</figure></div><br>

<div align="center"><figure>
    <img src="./img/img26.png" alt="img26"><br>
    <figcaption>Imagem 26.</figcaption>
</figure></div><br>




<div align="center"><figure>
    <img src="./img/img27.png" alt="img27"><br>
    <figcaption>Imagem 27.</figcaption>
</figure></div><br>



<div align="center"><figure>
    <img src="./img/img28.png" alt="img28"><br>
    <figcaption>Imagem 28.</figcaption>
</figure></div><br>



<div align="center"><figure>
    <img src="./img/img29.png" alt="img29"><br>
    <figcaption>Imagem 29.</figcaption>
</figure></div><br>



<div align="center"><figure>
    <img src="./img/img30.png" alt="img30"><br>
    <figcaption>Imagem 30.</figcaption>
</figure></div><br>



<div align="center"><figure>
    <img src="./img/img31.png" alt="img31"><br>
    <figcaption>Imagem 31.</figcaption>
</figure></div><br>

<a name="item1.4"><h4>1.4 Teste no Modo Blocking</h4></a>[Back to summary](#item1)








<a name="item1.5"><h4>1.5 Monitoramento com Dozzle</h4></a>[Back to summary](#item1)





<a name="item1.6"><h4>1.6 Coleta de Evid√™ncias</h4></a>[Back to summary](#item1)



<a name="item1.7"><h4>1.7 Documenta√ß√£o T√©cnica</h4></a>[Back to summary](#item1)

Ap√≥s finaliza√ß√£o do laborat√≥rio, chegou o momento de construir a documenta√ß√£o t√©cnica. Este arquivo de README √© a documenta√ß√£o padr√£o que realizo em todos meus projetos no meu GitHub, ela basicamente narra toda a forma como a atividade (bootcamp, curso, aula, laborat√≥rio, desafio, projeto) foi desenvolvida. J√° a documenta√ß√£o t√©cnica do projeto consistia no artefato principal entreg√°vel, bem como seus anexos. Este artefato foi o relat√≥rio t√©cnico que documentava de forma t√©cnica e estruturada o laborat√≥rio realizado, onde em anexos outros documentos parte do projeto podiam ser vinculados.

Um relat√≥rio t√©cnico de seguran√ßa normalmente segue uma estrutura l√≥gica e hier√°rquica, que garante clareza tanto para leitores t√©cnicos quanto para a gest√£o. A ordem pode variar um pouco conforme a institui√ß√£o (ex.: NIST, ISO, frameworks de IR), mas o modelo mais aceito √© algo assim:

Um relat√≥rio t√©cnico de seguran√ßa √© elaborado para documentar, analisar e comunicar informa√ß√µes sobre a prote√ß√£o de sistemas, redes ou aplica√ß√µes. A estrutura recomendada garante clareza, rastreabilidade e utilidade tanto para profissionais t√©cnicos quanto para gestores. A seguir, uma descri√ß√£o detalhada dos elementos mais comuns:
1. **Capa:** A capa identifica o relat√≥rio, contendo o t√≠tulo, autor(es), data e organiza√ß√£o respons√°vel. Serve para formalizar o documento e indicar sua autoria.
2. **Sum√°rio Executivo:** O sum√°rio executivo √© um resumo conciso do relat√≥rio, geralmente limitado a uma p√°gina. Destina-se a apresentar os principais achados, impactos e recomenda√ß√µes de forma r√°pida e acess√≠vel para tomadores de decis√£o, sem necessidade de leitura detalhada do documento.
3. **Objetivo:** Aqui se descreve o prop√≥sito do relat√≥rio, explicando o que foi analisado, testado ou documentado. Define a inten√ß√£o do trabalho e ajuda a contextualizar os resultados.
4. **Escopo:** O escopo delimita o que est√° inclu√≠do e exclu√≠do do estudo ou teste. Exemplos: sistemas, redes, aplica√ß√µes, per√≠odos de an√°lise, tipo de ataques simulados ou segmentos de infraestrutura.
5. **Metodologia:** A metodologia detalha os procedimentos, frameworks e ferramentas utilizados. Exemplos: frameworks de resposta a incidentes como NIST IR, t√©cnicas de ataque simuladas, ferramentas de monitoramento, logs analisados. Permite que outros profissionais reproduzam ou verifiquem o trabalho.
6. **Diagrama / Arquitetura:** Diagramas ou representa√ß√µes visuais do ambiente analisado ajudam a compreender a infraestrutura, rela√ß√µes entre sistemas, fluxos de dados e pontos de vulnerabilidade.  
7. **Evid√™ncias e Diagn√≥stico:** Nesta se√ß√£o, s√£o apresentados os dados coletados: prints, logs, outputs de comandos e achados t√©cnicos. Tamb√©m inclui an√°lise e interpreta√ß√£o das evid√™ncias, mostrando como os incidentes foram detectados, contidos e solucionados.
8. **Recomenda√ß√µes:** Sugest√µes para corrigir vulnerabilidades e melhorar a seguran√ßa, priorizando a√ß√µes cr√≠ticas ou de maior impacto. Deve ser pr√°tica e aplic√°vel.
9. **Plano de A√ß√£o:** Indica como implementar as recomenda√ß√µes, com a√ß√µes detalhadas, respons√°veis, prazos e prioridades, facilitando a execu√ß√£o e acompanhamento das melhorias.
10. **Conclus√£o:** S√≠ntese dos resultados do relat√≥rio, refor√ßando o estado final do ambiente, os principais aprendizados e eventuais limita√ß√µes do estudo.
11. **Anexos:** Materiais complementares, como configura√ß√µes completas, scripts, logs extensos, outputs detalhados ou qualquer arquivo que comprove as atividades executadas. Garantem rastreabilidade e permitem verifica√ß√£o detalhada.



