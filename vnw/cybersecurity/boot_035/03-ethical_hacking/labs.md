# Formação Cybersec - Labs Módulo 3   <img src="../0-aux/logo_boot.png" alt="boot_035" width="auto" height="45">

### Repository: [boot](../../../../)   
### Platform: <a href="../../../">vnw   <img src="https://github.com/PedroHeeger/my_tech_journey/blob/main/platforms/img/vnw.jpeg" alt="vnw" width="auto" height="25"></a>
### Software/Subject: <a href="../../">cybersecurity   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/content/cybersecurity.jpg" alt="cybersecurity" width="auto" height="25"></a>
### Bootcamp: <a href="../">boot_035 (Formação Cybersec)   <img src="../0-aux/logo_boot.png" alt="boot_035" width="auto" height="25"></a>
### Module: 3. Ethical Hacking (Red Team)

#### <a href="./README.md">Teoria</a>

---

Esta pasta refere-se aos laboratórios do módulo 3 **Ethical Hacking (Red Team)** do bootcamp [**Formação Cybersec**](../).

### Theme:
- Cybersecurity

### Used Tools:
- Operating System (OS): 
  - Linux   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/linux/linux-original.svg" alt="linux" width="auto" height="25">
  - Windows 11   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/windows11.png" alt="windows11" width="auto" height="25">
- Linux Distribution:
  - Ubuntu   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/ubuntu/ubuntu-plain.svg" alt="ubuntu" width="auto" height="25">
- Cloud:
  - AWS   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon@latest/icons/amazonwebservices/amazonwebservices-original-wordmark.svg" alt="aws" width="auto" height="25">
- Cloud Services:
  - Amazon Elastic Compute Cloud (EC2)   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/cloud/aws_ec2.svg" alt="aws_ec2" width="auto" height="25">
  - Google Drive   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/google_drive.png" alt="google_drive" width="auto" height="25">
- Containerization: 
  - Docker   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/docker/docker-original.svg" alt="docker" width="auto" height="25">
  - Docker Compose   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/docker_compose.png" alt="docker_compose" width="auto" height="25">
  - Docker Playground; Play With Docker (PWD)   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/sites/docker_playground.jpg" alt="docker_playground" width="auto" height="25">
- Build Automation:
  - Make   <img src="" alt="make" width="auto" height="25">
- Language:
  - HTML   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/html5/html5-original.svg" alt="html" width="auto" height="25">
  - Markdown   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/markdown/markdown-original.svg" alt="markdown" width="auto" height="25">
- Integrated Development Environment (IDE) and Text Editor:
  - Nano   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/nano.png" alt="nano" width="auto" height="25">
  - Vi   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/vi.png" alt="vi" width="auto" height="25">
  - VI iMproved (Vim)   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/vim/vim-original.svg" alt="vim" width="auto" height="25">
  - Visual Studio Code (VS Code)   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/vscode/vscode-original.svg" alt="vscode" width="auto" height="25">
- Versioning: 
  - Git   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/git/git-original.svg" alt="git" width="auto" height="25">
- Repository:
  - GitHub   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/github/github-original.svg" alt="github" width="auto" height="25">
- Command Line Interpreter (CLI):
  - AWS Command Line Interface (CLI)   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/cloud/aws_cli.svg" alt="aws_cli" width="auto" height="25">
  - Bash e Sh   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/bash/bash-original.svg" alt="bash_sh" width="auto" height="25">
- Tools:
  - Advanced Package Tool (Apt)   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/apt.png" alt="apt" width="auto" height="25">
  - Advanced Package Tool (Apt-Get)   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/apt-get.jpg" alt="apt-get" width="auto" height="25">
  - Curl   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/curl.png" alt="curl" width="auto" height="25">
- Network:
  - netstat   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/netstat.webp" alt="netstat" width="auto" height="25">
  - Nmap   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/nmap.png" alt="nmap" width="auto" height="25">
  - OpenSSH   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/openssh.png" alt="openssh" width="auto" height="25">
  - OWASP Juice Shop   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/sites/owasp_juice_shop.png" alt="owasp_juice_shop" width="auto" height="25">
  - OWASP ModSecurity Core Rule Set (OWASP ModSecurity CRS)   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/owasp_modesecurity_crs.png" alt="owasp_modesecurity_crs" width="auto" height="25">
  - Uncomplicated Firewall (UFW)   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/ufw.webp" alt="ufw" width="auto" height="25">
- Remote Desktop:
  - RealVNC Viewer   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/realvnc.png" alt="realvnc_viewer" width="auto" height="25">
- Cibersecurity:
  - Docker Bench for Security   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/docker_bench_for_security.png" alt="docker_bench_for_security" width="auto" height="25">
  - Kali Linux   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/kali_linux.png" alt="kali_linux" width="auto" height="25">
  - Sqlmap   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/sqlmap.png" alt="sqlmap" width="auto" height="25">
  - Trivy   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/trivy.png" alt="trivy" width="auto" height="25">
- SysAdm:
  - Xfce   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/xfce.svg" alt="xfce" width="auto" height="25">

---

### Bootcamp Module 3 Structure:
3. <a name="item3">Módulo 3: Ethical Hacking (Red Team)<br>
  3.1 <a href="#item3.1">Pentest: Metodologia & Regras de Engajamento</a><br>
  3.2 <a href="#item3.2">Hardening de Servidores Linux</a><br>
  3.3 <a href="#item3.3">Firewall & ACL</a><br>
  3.4 <a href="#item3.4">IDS e IPS</a><br>
  3.5 <a href="#item3.5">Monitoramento de Logs</a><br>
  3.6 <a href="#item3.6">Patch Management</a><br>
  3.7 <a href="#item3.7">Cloud Security</a><br>
  3.8 <a href="#item3.8">IAM e Permissionamento</a><br>
  3.9 <a href="#item3.9">Container Security Docker Bench & Trivy</a><br>
  3.10 <a href="#item3.10">NIST & Resposta a Incidentes</a><br>

---

### Objective:
Desenvolver a mentalidade ofensiva necessária para simular ataques reais e transformar descobertas em evidências técnicas e recomendações acionáveis, por meio da aplicação de metodologias de pentest, exploração de vulnerabilidades com ferramentas como **Metasploit** e **Burp Suite**, técnicas de quebra de credenciais, escalonamento de privilégios em **Linux** e **Windows**, movimentação lateral, evasão de controles de defesa e elaboração de relatórios técnicos profissionais.

### Folder Structure:
- [README.md](./README.md): Documento escrito em **Markdown** descrevendo todo conteúdo teórico realizado neste módulo.
- [labs.md](./labs.md): Este documento de README, escrito em **Markdown**, descrevendo todos os laboratórios realizados neste módulo.

### Development:
Em cibersegurança, é prática comum e recomendada realizar laboratórios em ambientes controlados e seguros. Por isso, ferramentas como **Docker** ou máquinas virtuais são utilizadas para simular ambientes reais, protegendo a infraestrutura local, uma vez que o uso de ferramentas de ataque ou alterações em configurações de rede podem comprometer a integridade do sistema. O ambiente de laboratório é estruturado em duas partes: a primeira envolve a instalação dos softwares que virtualização um ambiente, como **WSL2**, **Docker** ou **VM VirtualBox**, além de ferramentas de suporte essenciais, como editores de código (**Visual Studio Code (VS Code)**) e sistemas de versionamento (**Git**).  

Neste curso, a virtualização do ambiente foi realizada principalmente com **Docker** em conjunto com **WSL**. No entanto, para a maioria dos labs utilizei o **Docker** em instâncias do **Amazon Elastic Compute Cloud (EC2)**, na nuvem da **Amazon Web Services (AWS)**, como alternativa de execução. Em pequenos casos, para realizar testes, a plataforma **Play With Docker (PWD)** também foi utilizada.

A criação da instância EC2 foi automatizada por meio do script [`ec2Instance.ps1`](../environment/ec2Instance.ps1), desenvolvido em **Windows PowerShell** utilizando comandos da **AWS Command Line Interface (CLI)**. O script está localizado na pasta [`environment`](../environment/) deste curso, pois foi o mesmo para todos os módulos. A instância foi provisionada com a imagem `ami-020cba7c55df1f615`, baseada no sistema operacional **Linux Ubuntu**, associada a um volume do **Amazon Elastic Block Store (EBS)** de `8 GB`, do tipo `gp` (General Purpose). O tipo de instância utilizado foi o `t3.medium`, com 2 vCPUs e 4 GB de memória. Para acesso, foi utilizado o par de chaves `keyPairUniversal`, previamente existente na conta da **AWS**, e o grupo de segurança atribuído à instância foi o `default` da zona de disponibilidade `us-east-1a` (Norte da Virgínia). Um script de *user data* foi utilizado para automatizar a instalação do **Git** e do **Docker** durante o processo de inicialização.

O acesso à instância podia ser feito tanto pelo console da **AWS** quanto por meio de conexão SSH utilizando o **OpenSSH** no **Windows PowerShell** da máquina local. Neste último caso, era necessário informar o caminho do arquivo de chave privada, o nome do usuário do sistema e o IP ou DNS público da instância. Um exemplo de comando seria: `ssh -i "G:/Meu Drive/4_PROJ/scripts/aws/.default/secrets/awsKeyPair/universal/keyPairUniversal.pem" ubuntu@54.160.249.118`. Além disso, o Security Group associado à instância precisava conter uma regra de entrada liberando a porta `22` para o IP público da máquina física, a fim de permitir o estabelecimento da conexão SSH. As máquinas virtuais do **Play With Docker (PWD)** também foram acessadas via SSH. Nesse caso, o próprio ambiente fornecia o comando necessário para a conexão, que podia ser executado diretamente no **Windows PowerShell**, sem necessidade de autenticação com chave privada ou senha.

A segunda parte do ambiente de laboratório consiste na construção do ambiente simulado propriamente dito. No caso do **Docker**, isso envolve a criação de containers, redes e volumes, realizada por meio de dois tipos principais de arquivos. O primeiro é o `docker-compose.yml`, que define de forma serial toda a estrutura a ser criada: quais e quantos containers, suas configurações, as imagens que irão utilizar e os volumes e redes que serão estabelecidos. O segundo tipo de arquivo, que pode existir mais de um por laboratório, são os `Dockerfile`, responsáveis por criar imagens específicas para cada container. Essas imagens podem ser enviadas a repositórios de imagens **Docker**, como o **DockerHub**, ou referenciadas diretamente no arquivo do **Docker Compose**.

Todos esses arquivos eram preparados pelo instrutor do curso e disponibilizados no [repositório](https://github.com/Kensei-CyberSec-Lab/formacao-cybersec/) do curso no perfil da plataforma **Vai na Web** no **GitHub**. O repositório era organizado pelos três módulos do curso, com pastas correspondentes a cada laboratório. Geralmente, o número do laboratório coincidia com o número da aula, embora nem todos os labs seguissem essa sequência e nem todas as aulas tivessem laboratórios. Em cada pasta de laboratório, além dos arquivos `docker-compose.yml` e `Dockerfile`, podiam existir arquivos complementares, como scripts, textos ou documentos **Markdown**, contendo informações relevantes ou conteúdos necessários para a execução do lab. Durante a realização de cada lab, além de executar os exercícios, foi feita uma explicação detalhada sobre a construção dos arquivos de **Docker Compose**,  **Docker** e as dependências utilizadas, evidenciando como o ambiente foi estruturado.

Para executar os arquivos e iniciar o ambiente de laboratório, a sequência de comandos utilizada era a seguinte:
- `git clone https://github.com/Kensei-CyberSec-Lab/formacao-cybersec.git`: Clonagem do repositório do bootcamp para o ambiente local, seja no **WSL**, em máquinas virtuais ou, como no meu caso, em instâncias **Amazon EC2**.
- `cd formacao-cybersec/modulo3-ethical-hacking/lab_1`: Navegação até o diretório do laboratório a ser executado. Para outros labs, bastava alterar as duas últimas pastas do caminho para o módulo e lab correspondentes.
- `docker compose up -d`: Inicialização do ambiente com **Docker Compose**. Este comando devia ser executado na pasta onde o arquivo `docker-compose.yml` estava localizado.
- `docker ps` e `docker network ls`: Verificação dos containers ativos e das redes existentes no ambiente.
- `docker exec -it kali /bin/bash`: Acesso a um container em execução. Bastava substituir `kali` pelo nome do container que desejava-se acessar.
- `docker compose down`: Encerramento do ambiente. Assim como na inicialização, este comando devia ser executado na pasta onde se encontrava o arquivo `docker-compose.yml`.
- `docker system prune -f`: Remoção containers parados, redes não usadas, imagens dangling (imagens sem tags) e caches de build.
- `docker system prune -a`: Remoção containers parados, redes não usadas, imagens dangling (imagens sem tags) e caches de build, além de remoção de todas as imagens não usadas por containers.

Os laboratórios de cibersegurança são organizados com máquinas de ataque, geralmente uma **Kali Linux**, e máquinas alvo ou de defesa, que são os sistemas onde os ataques são realizados. Pode haver múltiplas máquinas de cada tipo, sendo comum que algumas máquinas de defesa sejam propositalmente vulneráveis, incluindo aplicações web criadas para testes. Como o ambiente é simulado via **Docker**, termos como servidor, máquina, container ou host frequentemente se referem aos containers que representam as máquinas simuladas. Além disso, é importante ter em mente que existiam outras duas camadas no ambiente: a máquina física, no caso meu computador pessoal **Windows**, e a máquina virtual fornecida pela **AWS** ou pelo **Play With Docker (PWD)**, que hospedava e executava os containers do **Docker**.

Outra parte importante dos laboratórios foram os *Capture The Flag (CTF)*, desafios técnicos amplamente utilizados na área de cibersegurança para desenvolver e validar conhecimento prático. Cada desafio apresenta um cenário específico — como exploração de vulnerabilidades, análise de tráfego, OSINT ou engenharia reversa — e exige que o participante realize uma ação ou resolva um problema para obter a flag. A flag não se limita a uma string ou código a ser encontrado, ela representa a prova de que o objetivo do desafio foi cumprido com sucesso. Ao longo dos laboratórios do curso, diversos CTFs foram incorporados ao ambiente simulado, servindo como etapas práticas de validação do conteúdo e permitindo aplicar, de forma objetiva, os conceitos aprendidos. Dessa forma, os laboratórios não apenas simularam cenários reais de ataque e defesa, como também proporcionaram desafios progressivos que reforçaram o raciocínio lógico, a análise técnica e a consolidação do conhecimento.

<a name="item3.1"><h4>3.1 Pentest: Metodologia & Regras de Engajamento</h4></a>[Back to summary](#item3)   
[Material do Lab](https://github.com/Kensei-CyberSec-Lab/formacao-cybersec/tree/main/modulo3-ethical-hacking/lab_1)

Obs.: Laboratório registrado como 1, documento como 1 e referente a aula 1.

<details><summary><strong>Ambiente de Laboratório</strong></summary>
  <ul>
    <li><details><summary><strong>Docker Compose</strong></summary>
        <ul>
          <li><details><summary><strong>services:</strong></summary>
            <ul>
              <li><details><summary><strong>kali:</strong></summary>
                <ul>
                  <li><strong>build:</strong>
                    <ul>
                      <li><code>context: .</code>: Contexto da build é o diretório atual.</li>
                      <li><code>dockerfile: kali.Dockerfile</code>: Usa o arquivo <code>kali.Dockerfile</code> para construir a imagem.</li>
                    </ul>
                  </li>
                  <li><strong>container_name:</strong> Define o nome do container como <code>kensei_kali</code>.</li>
                  <li><code>tty: true</code>: Permite alocar um terminal interativo para o container.</li>
                  <li><code>stdin_open: true</code>: Mantém o STDIN aberto para uso com <code>docker exec -it</code>.</li>
                  <li><strong>volumes:</strong>
                    <ul>
                      <li><code>- ./labs:/home/kali/labs</code>: Monta o diretório local <code>./labs</code> dentro do container em <code>/home/kali/labs</code>, facilitando desenvolvimento e uso de scripts.</li>
                    </ul>
                  </li>
                  <li><strong>command:</strong> <code>/bin/bash</code>: Inicia o shell Bash, mantendo o container pronto para uso.</li>
                </ul>
              </details></li>
              <li><details><summary><strong>spiderfoot:</strong></summary>
                <ul>
                  <li><strong>build:</strong>
                    <ul>
                      <li><code>context: .</code>: Define o diretório atual como contexto da build.</li>
                      <li><code>dockerfile: Dockerfile.spiderfoot</code>: Usa o Dockerfile dedicado do SpiderFoot para construir a imagem.</li>
                    </ul>
                  </li>
                  <li><strong>container_name:</strong> Define o nome do container como <code>kensei_spiderfoot</code>.</li>
                  <li><strong>ports:</strong>
                    <ul>
                      <li><code>"5001:5001"</code>: Expõe a interface web do SpiderFoot na porta 5001 do host.</li>
                    </ul>
                  </li>
                  <li><strong>volumes:</strong>
                    <ul>
                      <li><code>- ./spiderfoot-data:/root/.spiderfoot</code>: Monta o diretório local <code>./spiderfoot-data</code> dentro do container em <code>/root/.spiderfoot</code>, garantindo que configurações, resultados e dados do SpiderFoot sejam persistidos entre reinicializações do container.</li>
                    </ul>
                  </li>
                </ul>
              </details></li>
              <li><details><summary><strong>neo4j:</strong></summary>
                <ul>
                  <li><strong>image:</strong> Usa a imagem oficial <code>neo4j:4.4</code>.</li>
                  <li><strong>container_name:</strong> Define o nome do container como <code>kensei_neo4j</code>.</li>
                  <li><strong>environment:</strong>
                    <ul>
                      <li><code>NEO4J_AUTH=neo4j/test</code>: Define usuário e senha iniciais (<code>neo4j</code> / <code>test</code>).</li>
                      <li><code>NEO4J_dbms_memory_heap_initial__size=512m</code>: Define o tamanho inicial do heap de memória do Neo4j como 512 MB.</li>
                      <li><code>NEO4J_dbms_memory_heap_max__size=1g</code>: Define o tamanho máximo do heap de memória do Neo4j como 1 GB.</li>
                    </ul>
                  </li>
                  <li><strong>ports:</strong>
                    <ul>
                      <li><code>"7474:7474"</code>: Mapeia a porta 7474 do container para a porta 7474 do host, permitindo acesso à interface web do Neo4j via navegador.</li>
                      <li><code>"7687:7687"</code>: Mapeia a porta 7687 do container para a porta 7687 do host, utilizada pelo Bolt protocol para conexão de drivers e aplicações ao Neo4j.</li>
                    </ul>
                  </li>
                  <li><strong>volumes:</strong>
                    <ul>
                      <li><code>- ./neo4j-data:/data</code>: Monta o diretório local <code>./neo4j-data</code> dentro do container em <code>/data</code>, garantindo que o banco de dados Neo4j seja persistido no host entre reinicializações do container.</li>
                    </ul>
                  </li>
                </ul>
              </details></li>
            </ul>
          </details></li>
          <li><details><summary><strong>networks:</strong></summary>
            <ul>
              <li><code>default:</code>
                <ul>
                  <li><strong>name:</strong> <code>kensei_lab_net</code>: Nomeia a rede padrão usada pelos serviços, garantindo comunicação entre containers dentro dessa rede.</li>
                </ul>
              </li>
            </ul>
          </details></li>
        </ul>
      </details></li>
    <li><details><summary><strong>Dockerfile</strong></summary>
      <ul>
        <li><details><summary><strong>Dockerfile.kali</strong></summary>
          <ul>
            <li><code>FROM kalilinux/kali-rolling</code>: Imagem base Kali Rolling.</li>
            <li><strong>RUN:</strong> Executa a instalação de ferramentas essenciais e limpa o cache para reduzir o tamanho da imagem:
              <ul>
                <li><code>apt-get update</code>: Atualiza a lista de pacotes disponíveis.</li>
                <li><code>apt-get install -y git curl jq python3-pip build-essential golang-go amass</code>: Instala ferramentas essenciais de desenvolvimento, rede e pentest.</li>
                <li><code>apt-get clean && rm -rf /var/lib/apt/lists/*</code>: Remove arquivos temporários e limpa cache do apt.</li>
              </ul>
            </li>
            <li><code>ENV GOPATH=/root/go</code>: Define a variável <code>GOPATH</code> apontando para <code>/root/go</code>, diretório onde o Go instalará pacotes e binários do usuário.</li>
            <li><code>ENV PATH=$PATH:/root/go/bin</code>: Adiciona <code>/root/go/bin</code> ao <code>PATH</code>, permitindo executar ferramentas instaladas via <code>go install</code>.</li>
            <li><code>RUN mkdir -p $GOPATH</code>: Cria diretório do GOPATH.</li>
            <li><strong>RUN:</strong> Instala ferramentas Go no <code>GOPATH</code> utilizando <code>go install ...@latest</code> e disponibiliza os binários em <code>/root/go/bin</code>:
              <ul>
                <li><code>go install github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest</code>: Instala o <strong>subfinder</strong>, usado para descoberta de subdomínios.</li>
                <li><code>go install github.com/projectdiscovery/httpx/cmd/httpx@latest</code>: Instala o <strong>httpx</strong>, utilizado para verificação e coleta de informações HTTP (status, headers, títulos, etc.).</li>
                <li><code>go install github.com/projectdiscovery/nuclei/v2/cmd/nuclei@latest</code>: Instala o <strong>nuclei</strong>, motor de scan de vulnerabilidades baseado em templates.</li>
                <li><code>go install github.com/hakluke/hakrawler@latest</code>: Instala o <strong>hakrawler</strong>, um crawler rápido para descoberta de endpoints e conteúdo web.</li>
                <li><code>go install github.com/zricethezav/gitleaks/v8@latest</code>: Instala o <strong>gitleaks</strong>, ferramenta para detecção de segredos e chaves em repositórios.</li>
              </ul>
            </li>
            <li><code>COPY scripts /home/kali/scripts</code>: Copia scripts locais para dentro do container.</li>
            <li><code>WORKDIR /home/kali</code>: Define diretório de trabalho.</li>
            <li><code>CMD ["/bin/bash"]</code>: Inicia o shell Bash.</li>
          </ul>
        </details></li>
        <li><details><summary><strong>Dockerfile.spiderfoot</strong></summary>
          <ul>
            <li><code>FROM python:3.10-slim</code>: Usa a imagem base Python 3.10 slim como ambiente inicial.</li>
            <li><strong>RUN</strong>:
              <ul>
                <li><code>apt-get update</code>: Atualiza a lista de pacotes.</li>
                <li><code>apt-get install -y --no-install-recommends git build-essential python3-dev libyaml-dev curl ca-certificates gcc g++ make libffi-dev libssl-dev</code>: Instala dependências do sistema necessárias para compilar e executar as dependências Python do SpiderFoot.</li>
                <li><code>rm -rf /var/lib/apt/lists/*</code>: Remove listas de pacotes para reduzir o tamanho final da imagem.</li>
              </ul>
            </li>
            <li><code>RUN pip3 install -U pip setuptools wheel cython</code>: Atualiza o gerenciador de pacotes Python e instala ferramentas de build (necessárias para compilar extensões como PyYAML).</li>
            <li><code>WORKDIR /app</code>: Define o diretório de trabalho para os comandos seguintes.</li>
            <li><code>RUN git clone --depth=1 --branch v4.0 https://github.com/smicallef/spiderfoot /app</code>: Clona a versão 4.0 do repositório SpiderFoot diretamente para <code>/app</code>.</li>
            <li><code>RUN sed -i 's/pyyaml>=5.4.1,<6/pyyaml>=6.0/' requirements.txt</code>: Altera a especificação do PyYAML no <code>requirements.txt</code> para uma versão compatível (quando necessário) antes da instalação das dependências.</li>
            <li><code>RUN pip3 install -r requirements.txt</code>: Instala as dependências Python do SpiderFoot listadas em <code>requirements.txt</code>.</li>
            <li><code>EXPOSE 5001</code>: Expõe a porta 5001, usada pela interface web do SpiderFoot.</li>
            <li><code>CMD ["python3", "sf.py", "-l", "0.0.0.0:5001"]</code>: Comando padrão para iniciar o SpiderFoot, fazendo-o escutar em todas as interfaces na porta 5001.</li>
          </ul>
        </details></li>
      </ul>
    </details></li>
  </ul>
</details>

O primeiro laboratório desse curso consistiu em executar um pentest em uma sistema vulneravel de uma empresa fictícia de nome Acme Corp, passando por várias etapas: reconhecimento, descoberta, exploração, enumeração, análise avançada, documentação. Esse sistma foi construído na **AWS** pelo instrutor do curso e teve seu acesso controlado apenas aos alunos do curso, evitando assim que 

O ambiente **Docker** foi implantado em uma instância **Amazon EC2** na **AWS** e é composto pelos três containers seguintes:
- `kensei_kali`: Kali Linux utilizado para ataque e reconhecimento. Contém ferramentas como **Subfinder**, **Httpx**, **Nuclei**, **Hakrawler**, **Gitleaks**, além de softwares como: **Python**, **curl**, **git**, **jq**, **build-essential**, **Golang** e **Amass**.
- `kensei_spiderfoot`: container executando o **SpiderFoot**.
- `kensei_neo4j`: container executando o **Neo4j**.

Antes de iniciar a primeira etapa, o reconhecimento, foi realizado o acesso ao container **Kali Linux** a partir da instância remota, utilizando o comando `docker exec -it kensei_kali /bin/bash`. Dentro do container, foi criada a pasta de trabalho `acme-corp` com `mkdir -p /home/kali/investigations/acme-corp` e em seguida acessado o diretório com `cd /home/kali/investigations/acme-corp`.

🔍 Fase 1 — Reconhecimento   
Na Fase 1, o objetivo foi enumerar todos os subdomínios associados ao domínio da Acme Corp (`acme-corp-lab.com`). A partir da máquina de ataque, acessada no container Kali, foi executado o **Subfinder** com o comando `subfinder -d acme-corp-lab.com -o subdomains.txt`, que coletou os subdomínios e salvou o resultado no arquivo `subdomains.txt`, dentro do diretório criado `/home/kali/investigations/acme-corp`. Em seguida, verificou‑se o conteúdo gerado com `cat /home/kali/investigations/acme-corp/subdomains.txt` para confirmar os subdomínios encontrados, conforme ilustrado na imagem 01.

<div align="center"><figure>
    <img src="../0-aux/md3-img01.png" alt="img01"><br>
    <figcaption>Imagem 01.</figcaption>
</figure></div><br>

Um dos subdomínios identificados apresentava o prefixo `old`, indicando tratar‑se de um sistema legado — normalmente mais suscetível a vulnerabilidades. Em seguida, executou‑se o **Amass** com tempo limitado para execução usando: `timeout 300 amass enum -passive -d acme-corp-lab.com -o amass_results.txt -v || echo "Amass timeout - continuando com Subfinder"`, de modo que quaisquer resultados fossem gravados em `amass_results.txt`. Por fim, verificou‑se o conteúdo retornado pelo Amass com o comando abaixo.

```bash
if [ -f amass_results.txt ]; then
    echo "=== RESULTADOS DO AMASS ==="
    cat amass_results.txt
else
    echo "Amass não completou - usando apenas resultados do Subfinder"
fi
```

O **Amass** demorou muito e não trouxe novas descobertas; por isso, foram utilizados apenas os resultados do **Subfinder**. Como alguns subdomínios poderiam não estar ativos, foi necessário verificar quais dos quatro listados respondiam. Para isso, executou-se o comando `cat subdomains.txt | dnsx -resp -silent -o resolved_subdomains.txt`, que consultou cada subdomínio e salvou as entradas resolvidas em `resolved_subdomains.txt`. Os resultados, conforme imagem 02, indicaram que todos os subdomínios resolviam para endereços IP distintos — situação que pode indicar uma infraestrutura distribuída ou a presença de balanceamento de carga.

<div align="center"><figure>
    <img src="../0-aux/md3-img02.png" alt="img02"><br>
    <figcaption>Imagem 02.</figcaption>
</figure></div><br>

Na sequência, foi utilizado o **httpx** para identificar os serviços expostos por cada subdomínio. O comando executado foi: `cat subdomains.txt | httpx -title -tech-detect -status-code -o live_web_services.txt`. Esse comando consultou cada subdomínio e gerou um relatório contendo o título da página, as tecnologias detectadas e o código de status HTTP, salvando todas as informações em `live_web_services.txt`. Ao verificar o conteúdo do arquivo com `cat live_web_services.txt`, conforme mostrado na imagem 03, foram obtidos os seguintes resultados:
- `www.acme-corp-lab.com`: site estático hospedado no **Amazon S3**, típico para o site principal.
- `admin.acme-corp-lab.com`: painel **WordPress**, alvo comum em testes de segurança a painéis administrativos.
- `old.acme-corp-lab.com`: retornou HTTP 301, indicando um redirecionamento.

<div align="center"><figure>
    <img src="../0-aux/md3-img03.png" alt="img03"><br>
    <figcaption>Imagem 03.</figcaption>
</figure></div><br>

🎯 Fase 2: - Descoberta   
Na fase de descoberta, foi realizado uma investigação aprofundada do subdomínio `old`, que era um redirecionamento. Muitas vezes redirecionamentos revelam informações interessantes. Dessa forma, foi executado o comando `curl -L -s http://old.acme-corp-lab.com/ > legacy_page.html` para seguir todos os redirecionamentos e na página final copiar o HTML dela para o arquivo `legacy_page.html`.








<a name="item3.2"><h4>3.2 Hardening de Servidores Linux</h4></a>[Back to summary](#item3)   
[Material do Lab](https://github.com/Kensei-CyberSec-Lab/formacao-cybersec/tree/main/modulo3-ethical-hacking/lab_2)






<a name="item3.3"><h4>3.3 Firewall & ACL</h4></a>[Back to summary](#item3)   
[Material do Lab](https://github.com/Kensei-CyberSec-Lab/formacao-cybersec/tree/main/modulo3-ethical-hacking/lab_3)






<a name="item3.4"><h4>3.4 IDS e IPS</h4></a>[Back to summary](#item3)   
[Material do Lab](https://github.com/Kensei-CyberSec-Lab/formacao-cybersec/tree/main/modulo3-ethical-hacking)

A aula 4 não teve nenhum laboratório ou o laboratório ainda não foi construído pelo professor do curso.


<a name="item3.5"><h4>3.5 Monitoramento de Logs</h4></a>[Back to summary](#item3)   
[Material do Lab](https://github.com/Kensei-CyberSec-Lab/formacao-cybersec/tree/main/modulo3-ethical-hacking)

A aula 5 não teve nenhum laboratório ou o laboratório ainda não foi construído pelo professor do curso.

<a name="item3.6"><h4>3.6 Patch Management</h4></a>[Back to summary](#item3)   
[Material do Lab](https://github.com/Kensei-CyberSec-Lab/formacao-cybersec/tree/main/modulo3-ethical-hacking/lab_4)






<a name="item3.7"><h4>3.7 Cloud Security</h4></a>[Back to summary](#item3)   
[Material do Lab](https://github.com/Kensei-CyberSec-Lab/formacao-cybersec/tree/main/modulo3-ethical-hacking/lab_7)

A aula 7 não teve nenhum laboratório ou o laboratório ainda não foi construído pelo professor do curso.

<a name="item3.8"><h4>3.8 IAM e Permissionamento</h4></a>[Back to summary](#item3)   
[Material do Lab](https://github.com/Kensei-CyberSec-Lab/formacao-cybersec/tree/main/modulo3-ethical-hacking/lab_8)

A aula 8 não teve nenhum laboratório ou o laboratório ainda não foi construído pelo professor do curso.


<a name="item3.9"><h4>3.9 Container Security Docker Bench & Trivy</h4></a>[Back to summary](#item3)   
[Material do Lab](https://github.com/Kensei-CyberSec-Lab/formacao-cybersec/tree/main/modulo3-ethical-hacking/lab_5)








<a name="item3.10"><h4>3.10 NIST & Resposta a Incidentes</h4></a>[Back to summary](#item3)   
[Material do Lab](https://github.com/Kensei-CyberSec-Lab/formacao-cybersec/tree/main/modulo3-ethical-hacking/lab_6)
