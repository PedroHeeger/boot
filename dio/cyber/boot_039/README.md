# Bootcamp Santander - Cibersegurança #2   <img src="./0-aux/logo_boot.png" alt="boot_039" width="auto" height="45">

### Repository: [boot](../../../)   
### Platform: <a href="../../">dio   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/plataforma/dio.jpeg" alt="dio" width="auto" height="25"></a>   
### Software/Subject: <a href="../">cybersecurity   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/content/cybersecurity.jpg" alt="cybersecurity" width="auto" height="25"></a>
### Bootcamp: <a href="./">boot_039 (Bootcamp Santander - Cibersegurança #2)   <img src="./0-aux/logo_boot.png" alt="boot_039" width="auto" height="25"></a>

#### <a href="https://github.com/PedroHeeger/my_tech_journey/blob/main/credentials/certificates/bootcamps/cybersecurity/251115_Cert_Bootcamp_Santander-Ciberseguranca_2_PH_DIO.pdf">Certificate</a>

---

### Theme:
- Cybersecurity

### Used Tools:
- Operating System (OS): 
  - Windows 11 <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/windows11.png" alt="windows11" width="auto" height="25">
- Cloud Services:
  - Google Drive <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/google_drive.png" alt="google_drive" width="auto" height="25">
- Language:
  - HTML   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/html5/html5-original.svg" alt="html" width="auto" height="25">
  - Markdown   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/markdown/markdown-original.svg" alt="markdown" width="auto" height="25">
  - Python   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/python/python-original.svg" alt="python" width="auto" height="25">
- Integrated Development Environment (IDE) and Text Editor:
  - VS Code   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/vscode/vscode-original.svg" alt="vscode" width="auto" height="25">
- Versioning: 
  - Git   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/git/git-original.svg" alt="git" width="auto" height="25">
- Repository:
  - GitHub   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/github/github-original.svg" alt="github" width="auto" height="25">

---

<a name="item0"><h3>Bootcamp Structure</h3></a>

1. Prepare-se Para Jornada (Onboarding)   
  1.1. Introdução à Cibersegurança com o Santander   
  1.2. Mentoria: Live de Lançamento - Bootcamp Santander Cibersegurança #2   
2. Fundamentos de Cibersegurança    
  2.1. [Príncipios da Cibersegurança](https://github.com/PedroHeeger/boot/tree/main/dio/cyber/boot_036/02-fund_cyber#item2.1)   
  2.2. [Conceitos e Práticas de Sistemas Operacionais e Máquinas Virtuais](https://github.com/PedroHeeger/boot/tree/main/dio/cyber/boot_036/02-fund_cyber#item2.2)   
  2.3. [Fundamentos de Redes de Computadores](https://github.com/PedroHeeger/boot/tree/main/dio/cyber/boot_036/02-fund_cyber#item2.3)   
  2.4. [Introdução à Deep Web e Anonimato](https://github.com/PedroHeeger/boot/tree/main/dio/cyber/boot_036/02-fund_cyber#item2.4)   
  2.5 Desafios de Código: Aperfeiçoe Sua Lógica e Pensamento Computacional   
  2.6. [Desafio de Código: Explorando Fundamentos de Cibersegurança com Desafios de Código em Python](https://github.com/PedroHeeger/boot/tree/main/dio/cyber/boot_039#item2.6)   
3. Fundamentos de Busca por Vulnerabilidades e Testes de Invasão   
  3.1. [Fundamentos de Testes de Invasão (Pentest)](https://github.com/PedroHeeger/boot/tree/main/dio/cyber/boot_036/03-testes_invasao#item3.1)   
  3.2. [Introdução à Coleta e Análise de Segurança Cibernética](https://github.com/PedroHeeger/boot/tree/main/dio/cyber/boot_036/03-testes_invasao#item3.2)   
  3.3. [Tópicos em Engenharia Social](https://github.com/PedroHeeger/boot/tree/main/dio/cyber/boot_036/03-testes_invasao#item3.3)   
  3.4. [Conceitos e Técnicas de Varredura de Rede](https://github.com/PedroHeeger/boot/tree/main/dio/cyber/boot_036/03-testes_invasao#item3.4)   
  3.5. [Princípios de Enumeração e Exploração de Vulnerabilidades](https://github.com/PedroHeeger/boot/tree/main/dio/cyber/boot_036/03-testes_invasao#item3.5)   
  3.6. Desafios de Projetos: Crie Um Portfólio Vencedor   
  3.7. [Desafio de projeto: Criação de um Phishing com o Kali Linux](https://github.com/PedroHeeger/boot/tree/main/dio/cyber/boot_036/03-testes_invasao#item3.6)   
  3.8. [Desafio de Código: Busca por Vulnerabilidades com Desafios de Código em Python](https://github.com/PedroHeeger/boot/tree/main/dio/cyber/boot_039#item3.8)   
4. Testes de Invasão e Busca Por Vulnerabilidades  
  4.1. [Técnicas de Exploração de Vulnerabilidades](https://github.com/PedroHeeger/boot/tree/main/dio/cyber/boot_036/04-explor_vulnerabilidade#item4.1)   
  4.2. [Pós-Exploração em Sistemas Comprometidos](https://github.com/PedroHeeger/boot/tree/main/dio/cyber/boot_036/04-explor_vulnerabilidade#item4.2)   
  4.3. [Man in the Middle: Ataques e Mitigações](https://github.com/PedroHeeger/boot/tree/main/dio/cyber/boot_036/04-explor_vulnerabilidade#item4.3)   
  4.4. [Desafio de projeto: Entendendo um Ransomware na Prática com Python](https://github.com/PedroHeeger/boot/tree/main/dio/cyber/boot_036/04-explor_vulnerabilidade#item4.4)   
  4.5 Avalie este Bootcamp
5. Outras Mentorias   
  5.1. [Mentoria: Engenharia Social - Estratégias para Profissionais de Cibersegurança](https://github.com/PedroHeeger/boot/tree/main/dio/cyber/boot_039#item5.1)   
  5.2. [Mentoria: Explorando os Princípios do Ethical Hacking - Fundamentos da Defesa Cibernética](https://github.com/PedroHeeger/boot/tree/main/dio/cyber/boot_039#item5.2)   
  5.3. [Mentoria: Como a Inteligência Artificial está Transformando a Detecção de Ameaças Cibernéticas](https://github.com/PedroHeeger/boot/tree/main/dio/cyber/boot_039#item5.3)   

---

### Objective:
Segue abaixo o objetivo deste bootcamp, conforme descrito na plataforma da **DIO**.
  
>Entenda como funciona a mente e as principais habilidades de um Hacker para estar sempre um passo à frente e criar sistemas impenetráveis!

>Domine os principais conceitos de Cibersegurança com um banco que entende do assunto e previna brechas e ataques conhecendo as principais técnicas, a deep web e o anonimato, testes de vulnerabilidade e os princípios do Hacking ético.

>Essa bolsa do Santander pode ser sua!

### Structure:
- A estrutura do bootcamp da plataforma **DIO** é dividida em módulos e cada módulo contém cursos e desafios, sendo este último podendo ser **Desafio de Projeto** ou **Desafio de Código**. 
- Para melhor organização deste bootcamp, a estruturação das pastas acompanhou a estrutura do bootcamp. Dessa forma, foram criadas sub-pastas para cada módulo ou curso desse bootcamp, sendo que nas sub-pastas dos módulos estão contidas as pastas ou arquivos dos desafios ou cursos realizados.
- Nos arquivos de README de cada módulo ou curso está descrito o que foi realizado em cada um, e podem ser acessado nos links clicáveis na opção **Bootcamp Strucutre**. Os links que não forem clicáveis, são de cursos ou módulos que, na sua maior parte ou inteiramente, foram assuntos teóricos e não possuem materiais.
- Alguns cursos podem ter sido desenvolvidos em outro bootcamp, já que são os mesmos cursos, portanto, a explicação sobre esses cursos e seus respectivos materiais vão está no outro bootcamp e podem ser acessados através dos links do **Bootcamp Structure**.
- A sub-pasta **0-aux** foi criada apenas para armazenar imagens auxiliares para a construção dos arquivos de README.md deste bootcamp.
- [2.6-dc_fund_ciberseguranca](./2.6-dc_fund_ciberseguranca/): Pasta do desafio de código do módulo 2.
- [3.8-dc_vulnerabilidades](./3.8-dc_vulnerabilidades/): Pasta do desafio de código do módulo 3.

### Development:
Cada desafio ou cursos tiveram seus desenvolvimentos específicos. Portanto, a explicação sobre cada uma deles está contida no README da sua respectiva pasta, que podem está armazenadas neste bootcamp ou em outros se já tiverem sido realizados anteriormente. Caso haja poucas atividades restantes a serem feitas para conclusão deste bootcamp, o desenvolvimento dessas atividades estará aqui abaixo, não sendo necessário a criação de sub-pastas.

Os itens restantes desse bootcamp foram três mentorias e dois desafios de código. Abaixo é explicado o que foi desenvolvido em cada uma dessas atividades.

<a name="item2.6"><h4>2.6 Desafio de Código: Explorando Fundamentos de Cibersegurança com Desafios de Código em Python</h4></a>[Back to summary](#item0)

A primeira atividade deste desafio de código ([check_integrity.py](./2.6-dc_fund_ciberseguranca/check_integrity.py)) consistiu em receber como entrada uma lista de pares de hashes, contendo um hash calculado e um hash esperado, e comparar se eles eram iguais, simulando uma verificação de integridade de arquivo. Para isso, foi criada uma função com uma estrutura de repetição que percorria cada par de hashes. Cada par era dividido utilizando a vírgula como delimitador e armazenado em duas variáveis: `hash_calculado` e `hash_esperado`. Em seguida, essas variáveis eram comparadas em uma estrutura condicional, utilizando o método `.strip()` para eliminar possíveis espaços em branco nos hashes. Por fim, os resultados da comparação eram impressos na tela, indicando se cada hash estava "Correto" ou "Inválido".

A segunda atividade ([services_enumerate.py](./2.6-dc_fund_ciberseguranca/services_enumerate.py)) foi um pouco mais complexa. O objetivo foi simular uma enumeração de serviços em um servidor, ou seja, a partir de uma lista de números de portas fornecida como entrada, exibir os serviços em execução nessas portas. Para isso, foram utilizadas duas funções e um dicionário que mapeava números de portas aos seus respectivos serviços.  

A primeira função, `main`, era chamada por padrão e recebia o input do usuário. Esses dados eram tratados para criar uma lista de números inteiros, separando os números pelo delimitador vírgula e removendo possíveis espaços em branco. A segunda função, `enumerate_services`, recebia essa lista de portas. Uma estrutura de repetição percorria cada elemento da lista e, para cada porta, uma estrutura condicional verificava se ela existia no dicionário. Caso existisse, o serviço correspondente era adicionado a uma nova lista; caso contrário, era adicionado o status `"Desconhecido"`. Por fim, essa lista de serviços era retornada para a função `main`, que a imprimia na tela.

<a name="item3.8"><h4>3.8 Desafio de Código: Busca por Vulnerabilidades com Desafios de Código em Python</h4></a>[Back to summary](#item0)

Esse segundo desafio de código também consistiu em duas atividades. A primeira delas, denominada [phishing.py](./3.8-dc_vulnerabilidades/phishing.py), tinha como objetivo simular uma verificação de phishing em e-mails. 

A partir de uma string que simulava o corpo de uma mensagem de e-mail, os espaços em branco eram eliminados e a mensagem era passada para a função `verificar_phishing`. Essa função verificava se alguma palavra da lista de palavras suspeitas estava presente na mensagem, comparando tudo em letras minúsculas para evitar falsos negativos. Se alguma palavra suspeita fosse encontrada, a função retornava "Phishing"; caso contrário, retornava "Seguro". Por fim, o resultado era exibido na tela.

A segunda atividade ([invasao_logs.py](3.8-dc_vulnerabilidades/invasao_logs.py)) foi um pouco mais complexa. O objetivo dela foi simular a detecção de tentativas de invasão com base em registros de logs. A partir de uma entrada composta por uma lista de registros no formato `id_usuario:status`, o sistema retornava se algum usuário era considerado um possível invasor, caso houvesse mais de 3 tentativas de acesso consecutivas malsucedidas.  

Para isso, a função `main` recebia a entrada de dados e a processava, criando uma lista de registros e removendo espaços em branco. Essa lista era então passada para a função `detectar_invasao`.  

A função `detectar_invasao` utilizava três variáveis de controle: `usuario_atual`, `tentativas_consecutivas` e `invasor_detectado`, inicializadas com `None`, `0` e `None`, respectivamente. Uma estrutura de repetição percorria a lista de registros, extraindo, para cada entrada, o `usuario` e o `status` com base no delimitador `:` e removendo espaços em branco.  

Se o usuário do registro fosse o mesmo do loop anterior, verificava-se se o status era `falha`, incrementando o contador de tentativas consecutivas. Caso o contador ultrapassasse 3, o usuário era classificado como invasor. Se o status fosse diferente de falha, o contador era zerado. Quando o usuário mudava, a função verificava se o usuário anterior havia acumulado mais de 3 falhas consecutivas, classificando-o como invasor, se aplicável. Em seguida, o `usuario_atual` era atualizado e o contador de tentativas consecutivas era iniciado em 1 se a nova tentativa fosse `falha` ou em 0 caso contrário.  

Ao final do loop, era feita uma última verificação para o último usuário da lista: se tivesse mais de 3 tentativas consecutivas malsucedidas, ele era registrado como invasor. O resultado final, seja o usuário invasor identificado ou a mensagem `"Nenhum invasor detectado"`, era retornado para a função `main`, que se encarregava de exibir a informação na tela.

<a name="item5.1"><h4>5.1 Mentoria: Engenharia Social - Estratégias para Profissionais de Cibersegurança</h4></a>[Back to summary](#item0)

<div align="Center"><figure>
    <img src="./0-aux/img01.png" alt="img01"><br>
    <figcaption>Imagem 01.</figcaption>
</figure></div><br>


<a name="item5.2"><h4>5.2 Mentoria: Explorando os Princípios do Ethical Hacking - Fundamentos da Defesa Cibernética</h4></a>[Back to summary](#item0)



<a name="item5.3"><h4>5.3 Mentoria: Como a Inteligência Artificial está Transformando a Detecção de Ameaças Cibernéticas</h4></a>[Back to summary](#item0)

