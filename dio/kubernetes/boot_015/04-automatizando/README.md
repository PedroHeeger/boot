# Formação Kubernetes Fundamentals - Módulo 4   <img src="../0-aux/logo_boot.png" alt="boot_015" width="auto" height="45">

### Repository: [boot](../../../../)   
### Platform: <a href="../../../">dio   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/plataforma/dio.jpeg" alt="dio" width="auto" height="25"></a>   
### Software/Subject: <a href="../../">kubernetes   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/kubernetes/kubernetes-plain.svg" alt="kubernetes" width="auto" height="25"></a>
### Bootcamp: <a href="../">boot_015 (Formação Kubernetes Fundamentals)   <img src="../0-aux/logo_boot.png" alt="boot_015" width="auto" height="25"></a>
### Module: 4. Automatizando Deployments com Kubernetes 

---

This folder refers to Module 4 **Automatizando Deployments com Kubernetes** from bootcamp [**Formação Kubernetes Fundamentals**](../).

### Theme:
- DevOps
- Distributed Computing

### Used Tools:
- Operating System (OS): 
  - Linux   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/linux/linux-original.svg" alt="linux" width="auto" height="25">
  - Windows 11   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/windows11.png" alt="windows11" width="auto" height="25">
- Linux Distribution:
  - Ubuntu   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/ubuntu/ubuntu-plain.svg" alt="ubuntu" width="auto" height="25">
- Virtualization: 
  - Oracle VM VirtualBox   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/vm_virtualbox.png" alt="vm_virtualbox" width="auto" height="25">
- Cloud Services:
  - Amazon Elastic Compute Cloud (EC2)   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/cloud/aws_ec2.svg" alt="aws_ec2" width="auto" height="25">
  - Google Drive <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/google_drive.png" alt="google_drive" width="auto" height="25">
- Containerization: 
  - Docker   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/docker/docker-original.svg" alt="docker" width="auto" height="25">
- Cluster Management Software:
  - Kubernetes   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/kubernetes/kubernetes-plain.svg" alt="kubernetes" width="auto" height="25">
  - MiniKube   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/minikube.jpg" alt="minikube" width="auto" height="25">
- Language:
  - HTML   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/html5/html5-original.svg" alt="html" width="auto" height="25">
  - Markdown   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/markdown/markdown-original.svg" alt="markdown" width="auto" height="25">
  - YAML   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/yaml.png" alt="yaml" width="auto" height="25">
- Integrated Development Environment (IDE) and Text Editor:
  - Nano   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/nano.png" alt="nano" width="auto" height="25">
  - Vi   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/vi.png" alt="vi" width="auto" height="25">
  - VI iMproved (Vim)   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/vim/vim-original.svg" alt="vim" width="auto" height="25">
  - Visual Studio Code (VS Code)   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/vscode/vscode-original.svg" alt="vscode" width="auto" height="25">
- Versioning: 
  - Git   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/git/git-original.svg" alt="git" width="auto" height="25">
- Repository:
  - GitHub   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/github/github-original.svg" alt="github" width="auto" height="25">
- Command Line Interpreter (CLI):
  - AWS Command Line Interface (CLI)   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/cloud/aws_cli.svg" alt="aws_cli" width="auto" height="25">
  - Bash e Sh   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/bash/bash-original.svg" alt="bash_sh" width="auto" height="25">
  - Kubectl   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/kubernetes/kubernetes-plain.svg" alt="kubernetes" width="auto" height="25">
  - Oh My Zshell (Oh My ZSh)   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/oh_my_zshell.png" alt="oh_my_zshell" width="auto" height="25">
  - ZShell   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/zshell.png" alt="zshell" width="auto" height="25">
- Server and Databases:
  - Apache HTTP Server (httpd)   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/apache_http_server.png" alt="apache_httpd" width="auto" height="25">
  - MySQL Server   <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/mysql/mysql-original.svg" alt="mysql_server" width="auto" height="25">
- Database Administration Tool:
  - DBeaver   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/dbeaver.png" alt="dbeaver" width="auto" height="25">
- Tools:
  - Advanced Package Tool (Apt)   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/apt.png" alt="apt" width="auto" height="25">
  - Advanced Package Tool (Apt-Get)   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/apt-get.jpg" alt="apt-get" width="auto" height="25">
  - Curl   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/curl.png" alt="curl" width="auto" height="25">
  - Wget   <img src="https://github.com/PedroHeeger/main/blob/main/0-aux/logos/software/wget.webp" alt="wget" width="auto" height="25">

---

### Bootcamp Module 4 Structure
4. <a name="item2">Automatizando Deployments com Kubernetes</a><br>
  4.1. <a href="#item4.1">Deployment e Roolback em Clusters Kubernetes</a><br>
  4.2. <a href="#item4.2">CI-CD Utilizando Kubernetes</a><br>
  4.3. <a href="#item4.3">Criando um Pipeline de Deploy com GitLab e Kubernetes</a><br>
  4.4. Materiais Complementares: Arquitetura e Deploy de Microsserviços  

---

### Objective:
O objetivo deste módulo do bootcamp foi aprender sobre os conceitos de virtualização, container, microsserviços, além dos comandos básicos para se trabalhar com o software **Docker**.

### Structure:
A estrutura das pastas obedeceu a estruturação do bootcamp, ou seja, conforme foi necessário, sub-pastas foram criadas para os cursos específicos deste módulo. Na imagem 01 é exibida a estruturação das pastas. 

<div align="Center"><figure>
    <img src="../0-aux/md4-img01.png" alt="img01"><br>
    <figcaption>Imagem 01.</figcaption>
</figure></div><br>

### Development:
O desenvolvimento deste módulo do Bootcamp foi dividido em dois cursos. Abaixo é explicado o que foi desenvolvido em cada uma dessas atividades.

<a name="item4.1"><h4>4.1 Deployment e Roolback em Clusters Kubernetes</h4></a>[Back to summary](#item4) | <a href="">Certificate</a>

No primeiro curso do último módulo, foi explicado sobre o roolback que é quando um deployment implantado em uma versão mais nova precisa voltar para versão anterior. Para que isso ocorresse, ao implantar o deployment ou qualquer outro objeto **Kubernetes** era necessário registrar o comando de implantação. A pasta [rollout](./rollout/) foi construída na instância do EC2 e dentro dela o arquivo [deploy.yml](./rollout/deploy.yml) foi elaborado para exemplificar esta situação. Este arquivo criou um deployment com 3 réplicas, cujo nome dele, da label, do seletor, da label do template e do container foi `httpd`. A imagem utilizada foi a `httpd:2` e a porta onde seria executada o servidor web **Apache HTTP (Httpd)** era a `80`. No diretório do arquivo, com o comando `kubectl apply -f deploy.yml --record` foi utilizado o parâmetro `--record` que registrava os comandos em um histórico.
A visualização desse histórico foi realizada com execução do comando `kubectl rollout history deployment httpd`, conforme imagem 02.

<div align="Center"><figure>
    <img src="../0-aux/md4-img02.png" alt="img02"><br>
    <figcaption>Imagem 02.</figcaption>
</figure></div><br>

Após isso, o mesmo arquivo de deployment foi modificado, alterando a imagem do container para `httpd:latest` e novamente com o comando `kubectl apply -f deploy.yml --record` essa nova implantação foi realizada. Ao consultar o histórico com o comando `kubectl rollout history deployment httpd`, agora existiam dois registros, o primeiro na versão 2 e o segundo na versão `latest` que era a que estava implantada no momento. Novamente, o arquivo de deployment foi alterado, modificando a imagem agora para `httpd:errado` que era uma imagem que não existe, só para provocar o erro. Ao consultar o histórico, conforme imagem 03, agora existem três registros, sendo o terceiro em execução que era o que possuía a imagem incorreta.

<div align="Center"><figure>
    <img src="../0-aux/md4-img03.png" alt="img03"><br>
    <figcaption>Imagem 03.</figcaption>
</figure></div><br>

Com esse histórico foi possível aproveitá-lo para executar o roolback que era justamente voltar para a revisão 2 cujo a imagem era a `latest`. Então foi utilizado o comando `kubectl rollout undo deploy.yml` e com o comando `kubectl describe httpd` foi possível verificar que a imagem utilizada era agora a `latest`, evidenciado na imagem 04.

<div align="Center"><figure>
    <img src="../0-aux/md4-img04.png" alt="img04"><br>
    <figcaption>Imagem 04.</figcaption>
</figure></div><br>

No histórico a revisão utilizada era a 3 que tinha a imagem `errada`, quando o roolback foi realizado, retornou para revisão 2, cuja imagem era `latest`, e essa revisão 2 passou a ser a revisão 4, não existindo mais a revisão 2. Isso é mostrado na imagem 05 a seguir. Caso fosse executado novamente o comando de roolback, a revisão iria de 4 para 3, ou seja, a imagem do container alteraria de `latest` para `errada`.

<div align="Center"><figure>
    <img src="../0-aux/md4-img05.png" alt="img05"><br>
    <figcaption>Imagem 05.</figcaption>
</figure></div><br>

Com o comando `kubectl rollout undo deployment_name --to-revision=1` agora era definido para qual revisão deveria ser retornado ao realizar o roolback. Logo a revisão 1, cuja imagem era `2`, tornou-se revision 5, e a 1 não existia mais. A imagem 06 mostra o histórico de revisões. Enquanto a imagem 07 exibe a imagem do container na revisão atual do deployment. 

<div align="Center"><figure>
    <img src="../0-aux/md4-img06.png" alt="img06"><br>
    <figcaption>Imagem 06.</figcaption>
</figure></div><br>

<div align="Center"><figure>
    <img src="../0-aux/md4-img07.png" alt="img07"><br>
    <figcaption>Imagem 07.</figcaption>
</figure></div><br>

Em todo esse processo, na verdade, o deployment era o mesmo, o que modificava era o replicaset. O replicaset garante que um número específico de réplicas de pod esteja em execução a qualquer momento. Então o que era alterado era o replicaset e cada replicaset tinha seus pods com containers utilizando a imagem determinada.

Para melhor organização com relação ao arquivo de manifesto **YAML** é indicado utilizar um número determinando a revisão, por exemplo `app-html1.0.yml`. Assim quando for listado no histórico os comandos executados, cada arquivo vai ter seu nome com um número de revisão que facilitará a identificação. Nesse caso, seria necessário criar cada arquivo individualmente com suas modificações, mesmo que mínimas. Na imagem 08 é mostrado o histórico com os nomes de arquivos com suas respectivas revisões.

<div align="Center"><figure>
    <img src="../0-aux/md4-img08.png" alt="img08"><br>
    <figcaption>Imagem 08.</figcaption>
</figure></div><br>

Nessa próxima etapa foi abordado sobre a *Secret*, que é um objeto do **Kubernetes** que contém uma pequena quantidade de informação sensível, como senhas, tokens ou chaves. Este tipo de informação poderia, em outras circunstâncias, ser colocada diretamente em uma configuração de Pod ou em uma imagem de container. O uso de Secrets evita que seja incluído dados confidenciais no código. Secrets podem ser criados de forma independente dos Pods que os consomem. Isto reduz o risco de que o Secret e seus dados sejam expostos durante o processo de criação, visualização e edição ou atualização de Pods.

Um novo arquivo de manifesto **YAML** de nome [secrets.yml](./rollout/secrets.yml) foi elaborado dentro da pasta `rollout`. Este construíu um objeto secret de nome `my-secret`, definindo o tipo `Opaque` e em `data` um par chave e valor de uma variável de ambiente e seu valor. Nesse caso, foram criadas as variáveis `ROOT_PASSWORD` e `MYSQL_DATABASE` que seria informadas no arquivo de deployment do banco de dados. Com o comando `kubectl apply -f secrets.yml`, o objeto secrets foi implantado e foi exibido com o comando `kubectl get secret`, conforme imagem 09.

<div align="Center"><figure>
    <img src="../0-aux/md4-img09.png" alt="img09"><br>
    <figcaption>Imagem 09.</figcaption>
</figure></div><br>

Com o secret implatando, um arquivo de deployment de banco de dados **MySQL Server** foi desenvolvido. O nome desse arquivo foi [mysql.yml](./rollout/mysql.yml) e o nome do deployment foi `mysql-deployment`. A label, o seletor, a label do template e o nome do container foram definidos como `mysql`. O número de réplicas foi de apenas `1`, a imagem utilizada no container foi `mysql:5:7` e a porta foi a padrão do MySQL (`3306`). A grande mudança foi na forma como as variáveis de ambientes eram definidas, agora com utilização das secrets sem passar informações sensíveis direto no código. Utilizando o comando `kubectl describe pod pod_name`, perceba que as variáveis não estão referenciadas no pod, conforme comprovado na imagem 10 abaixo.

<div align="Center"><figure>
    <img src="../0-aux/md4-img10.png" alt="img10"><br>
    <figcaption>Imagem 10.</figcaption>
</figure></div><br>

<a name="item4.2"><h4>4.2 CI-CD Utilizando Kubernetes</h4></a>[Back to summary](#item4) | <a href=" ">Certificate</a>






<a name="item4.3"><h4>4.3 Criando um Pipeline de Deploy com GitLab e Kubernetes</h4></a>[Back to summary](#item4) | <a href=" ">Certificate</a>